"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/pdf-viewer/pdf-viewer.tsx":
/*!**************************************************!*\
  !*** ./src/components/pdf-viewer/pdf-viewer.tsx ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PdfViewer: function() { return /* binding */ PdfViewer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ PdfViewer auto */ \nvar _s = $RefreshSig$();\n\nfunction PdfViewer(param) {\n    let { url, documentId, accessToken } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"idle\");\n    const [errorMessage, setErrorMessage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [pageMeta, setPageMeta] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const pageMetaRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({});\n    const [documentResult, setDocumentResult] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const wordRectsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({});\n    const selectionRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const popupRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const selectionStateRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let cancelled = false;\n        const render = async ()=>{\n            setState(\"loading\");\n            setErrorMessage(null);\n            const container = containerRef.current;\n            if (!container) return;\n            container.innerHTML = \"\";\n            try {\n                const pdfjs = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pdfjs-dist_legacy_build_pdf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! pdfjs-dist/legacy/build/pdf */ \"(app-pages-browser)/./node_modules/pdfjs-dist/legacy/build/pdf.mjs\"));\n                pdfjs.GlobalWorkerOptions.workerSrc = \"/pdf.worker.min.mjs\";\n                const loadingTask = pdfjs.getDocument({\n                    url\n                });\n                const pdf = await loadingTask.promise;\n                if (cancelled) return;\n                const containerWidth = container.clientWidth || 720;\n                const nextMeta = {};\n                for(let pageNum = 1; pageNum <= pdf.numPages; pageNum += 1){\n                    const page = await pdf.getPage(pageNum);\n                    if (cancelled) return;\n                    const viewport = page.getViewport({\n                        scale: 1\n                    });\n                    const pageWidth = Math.min(containerWidth, 900);\n                    const scale = pageWidth / viewport.width;\n                    const scaled = page.getViewport({\n                        scale\n                    });\n                    const pageWrapper = document.createElement(\"div\");\n                    pageWrapper.className = \"pdf-embed__page\";\n                    pageWrapper.dataset.pageNumber = String(pageNum);\n                    pageWrapper.style.width = \"\".concat(Math.floor(scaled.width), \"px\");\n                    pageWrapper.style.margin = \"0 auto\";\n                    const canvas = document.createElement(\"canvas\");\n                    canvas.className = \"pdf-embed__canvas\";\n                    canvas.width = Math.floor(scaled.width);\n                    canvas.height = Math.floor(scaled.height);\n                    const overlay = document.createElement(\"div\");\n                    overlay.className = \"pdf-embed__overlay\";\n                    overlay.style.width = \"\".concat(Math.floor(scaled.width), \"px\");\n                    overlay.style.height = \"\".concat(Math.floor(scaled.height), \"px\");\n                    overlay.dataset.pageNumber = String(pageNum);\n                    overlay.addEventListener(\"pointermove\", handlePointerMove);\n                    overlay.addEventListener(\"pointerleave\", handlePointerLeave);\n                    overlay.addEventListener(\"pointerdown\", handlePointerDown);\n                    overlay.addEventListener(\"pointerup\", handlePointerUp);\n                    overlay.addEventListener(\"pointerdown\", ()=>{\n                        if (popupRef.current) {\n                            popupRef.current.remove();\n                            popupRef.current = null;\n                        }\n                    });\n                    pageWrapper.appendChild(canvas);\n                    pageWrapper.appendChild(overlay);\n                    container.appendChild(pageWrapper);\n                    const context = canvas.getContext(\"2d\");\n                    if (!context) continue;\n                    await page.render({\n                        canvasContext: context,\n                        viewport: scaled\n                    }).promise;\n                    const existing = pageMetaRef.current[pageNum];\n                    nextMeta[pageNum] = {\n                        width: Math.floor(scaled.width),\n                        height: Math.floor(scaled.height),\n                        widthInch: (existing === null || existing === void 0 ? void 0 : existing.widthInch) && existing.widthInch > 0 ? existing.widthInch : viewport.width,\n                        heightInch: (existing === null || existing === void 0 ? void 0 : existing.heightInch) && existing.heightInch > 0 ? existing.heightInch : viewport.height\n                    };\n                }\n                if (!cancelled) {\n                    setPageMeta(nextMeta);\n                    setState(\"idle\");\n                }\n            } catch (error) {\n                if (!cancelled) {\n                    setState(\"error\");\n                    const message = error instanceof Error ? error.message : \"PDFを表示できませんでした\";\n                    setErrorMessage(message);\n                }\n            }\n        };\n        void render();\n        return ()=>{\n            cancelled = true;\n            if (containerRef.current) {\n                containerRef.current.innerHTML = \"\";\n            }\n        };\n    }, [\n        url\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        pageMetaRef.current = pageMeta;\n    }, [\n        pageMeta\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const loadResult = async ()=>{\n            if (!documentId || !accessToken) {\n                setDocumentResult(null);\n                return;\n            }\n            try {\n                var _process_env_NEXT_PUBLIC_API_BASE_URL;\n                const baseUrl = (_process_env_NEXT_PUBLIC_API_BASE_URL = \"http://127.0.0.1:8000\") !== null && _process_env_NEXT_PUBLIC_API_BASE_URL !== void 0 ? _process_env_NEXT_PUBLIC_API_BASE_URL : \"http://127.0.0.1:8000\";\n                const response = await fetch(\"\".concat(baseUrl, \"/documents/\").concat(documentId, \"/result\"), {\n                    headers: {\n                        Authorization: \"Bearer \".concat(accessToken)\n                    }\n                });\n                if (!response.ok) return;\n                const result = await response.json();\n                setDocumentResult(result);\n                const pages = Array.isArray(result.pages) ? result.pages : [];\n                if (pages.length > 0) {\n                    setPageMeta((prev)=>{\n                        const merged = {\n                            ...prev\n                        };\n                        for (const page of pages){\n                            var _prev_pageNumber, _prev_pageNumber1, _prev_pageNumber2, _prev_pageNumber3;\n                            var _page_pageNumber;\n                            const pageNumber = Number((_page_pageNumber = page.pageNumber) !== null && _page_pageNumber !== void 0 ? _page_pageNumber : page.page_number);\n                            if (!pageNumber) continue;\n                            var _page_width;\n                            const widthInch = Number((_page_width = page.width) !== null && _page_width !== void 0 ? _page_width : page.widthInch);\n                            var _page_height;\n                            const heightInch = Number((_page_height = page.height) !== null && _page_height !== void 0 ? _page_height : page.heightInch);\n                            var _prev_pageNumber_width, _prev_pageNumber_height, _prev_pageNumber_widthInch, _prev_pageNumber_heightInch;\n                            merged[pageNumber] = {\n                                width: (_prev_pageNumber_width = (_prev_pageNumber = prev[pageNumber]) === null || _prev_pageNumber === void 0 ? void 0 : _prev_pageNumber.width) !== null && _prev_pageNumber_width !== void 0 ? _prev_pageNumber_width : 0,\n                                height: (_prev_pageNumber_height = (_prev_pageNumber1 = prev[pageNumber]) === null || _prev_pageNumber1 === void 0 ? void 0 : _prev_pageNumber1.height) !== null && _prev_pageNumber_height !== void 0 ? _prev_pageNumber_height : 0,\n                                widthInch: Number.isFinite(widthInch) ? widthInch : (_prev_pageNumber_widthInch = (_prev_pageNumber2 = prev[pageNumber]) === null || _prev_pageNumber2 === void 0 ? void 0 : _prev_pageNumber2.widthInch) !== null && _prev_pageNumber_widthInch !== void 0 ? _prev_pageNumber_widthInch : 0,\n                                heightInch: Number.isFinite(heightInch) ? heightInch : (_prev_pageNumber_heightInch = (_prev_pageNumber3 = prev[pageNumber]) === null || _prev_pageNumber3 === void 0 ? void 0 : _prev_pageNumber3.heightInch) !== null && _prev_pageNumber_heightInch !== void 0 ? _prev_pageNumber_heightInch : 0\n                            };\n                        }\n                        return merged;\n                    });\n                }\n                const nextRects = {};\n                const polygonToRect = (polygon)=>{\n                    const xs = [];\n                    const ys = [];\n                    for(let i = 0; i < polygon.length; i += 2){\n                        xs.push(polygon[i]);\n                        ys.push(polygon[i + 1]);\n                    }\n                    const left = Math.min(...xs);\n                    const right = Math.max(...xs);\n                    const top = Math.min(...ys);\n                    const bottom = Math.max(...ys);\n                    return {\n                        left,\n                        top,\n                        width: right - left,\n                        height: bottom - top\n                    };\n                };\n                for (const page of pages){\n                    var _page_pageNumber;\n                    const pageNumber = Number((_page_pageNumber = page.pageNumber) !== null && _page_pageNumber !== void 0 ? _page_pageNumber : page.page_number);\n                    var _page_width;\n                    const width = Number((_page_width = page.width) !== null && _page_width !== void 0 ? _page_width : page.widthInch);\n                    var _page_height;\n                    const height = Number((_page_height = page.height) !== null && _page_height !== void 0 ? _page_height : page.heightInch);\n                    if (!pageNumber || !Number.isFinite(width) || !Number.isFinite(height)) continue;\n                    const words = Array.isArray(page.words) ? page.words : [];\n                    const lines = Array.isArray(page.lines) ? page.lines : [];\n                    const wordToLine = new Map();\n                    lines.forEach((line, index)=>{\n                        const indexes = Array.isArray(line.word_indexes) ? line.word_indexes : Array.isArray(line.wordIndexes) ? line.wordIndexes : [];\n                        for (const wordIndex of indexes){\n                            if (Number.isFinite(wordIndex)) {\n                                wordToLine.set(Number(wordIndex), index);\n                            }\n                        }\n                    });\n                    for (const word of words){\n                        if (!Array.isArray(word.polygon)) continue;\n                        const rect = polygonToRect(word.polygon);\n                        var _word_word_index;\n                        const wordIndex = Number((_word_word_index = word.word_index) !== null && _word_word_index !== void 0 ? _word_word_index : word.wordIndex);\n                        if (!Number.isFinite(wordIndex)) continue;\n                        const matched = (()=>{\n                            for (const line of lines){\n                                const indexes = Array.isArray(line.word_indexes) ? line.word_indexes : Array.isArray(line.wordIndexes) ? line.wordIndexes : [];\n                                if (indexes.includes(wordIndex)) {\n                                    if (!Array.isArray(line.polygon)) return null;\n                                    const lineRect = polygonToRect(line.polygon);\n                                    return {\n                                        top: lineRect.top / height,\n                                        height: lineRect.height / height\n                                    };\n                                }\n                            }\n                            return null;\n                        })();\n                        if (!nextRects[pageNumber]) nextRects[pageNumber] = [];\n                        var _wordToLine_get;\n                        const normalized = {\n                            wordIndex,\n                            lineId: (_wordToLine_get = wordToLine.get(wordIndex)) !== null && _wordToLine_get !== void 0 ? _wordToLine_get : null,\n                            left: rect.left / width,\n                            top: rect.top / height,\n                            width: rect.width / width,\n                            height: rect.height / height\n                        };\n                        if (matched) {\n                            normalized.top = matched.top;\n                            normalized.height = matched.height;\n                        }\n                        nextRects[pageNumber].push(normalized);\n                    }\n                }\n                for (const key of Object.keys(nextRects)){\n                    nextRects[Number(key)].sort((a, b)=>a.wordIndex - b.wordIndex);\n                }\n                wordRectsRef.current = nextRects;\n            } catch (e) {\n                setDocumentResult(null);\n            }\n        };\n        void loadResult();\n    }, [\n        documentId,\n        accessToken\n    ]);\n    const handlePointerMove = (event)=>{\n        var _target_parentElement;\n        const target = event.currentTarget;\n        var _target_dataset_pageNumber;\n        const pageNumber = Number((_target_dataset_pageNumber = target.dataset.pageNumber) !== null && _target_dataset_pageNumber !== void 0 ? _target_dataset_pageNumber : (_target_parentElement = target.parentElement) === null || _target_parentElement === void 0 ? void 0 : _target_parentElement.dataset.pageNumber);\n        if (!pageNumber) return;\n        if (selectionStateRef.current) {\n            var _overlay_parentElement;\n            var _getOverlayFromPoint;\n            const overlay = (_getOverlayFromPoint = getOverlayFromPoint(event.clientX, event.clientY)) !== null && _getOverlayFromPoint !== void 0 ? _getOverlayFromPoint : target;\n            var _overlay_dataset_pageNumber;\n            const activePageNumber = Number((_overlay_dataset_pageNumber = overlay.dataset.pageNumber) !== null && _overlay_dataset_pageNumber !== void 0 ? _overlay_dataset_pageNumber : (_overlay_parentElement = overlay.parentElement) === null || _overlay_parentElement === void 0 ? void 0 : _overlay_parentElement.dataset.pageNumber);\n            if (!activePageNumber) return;\n            const rect = overlay.getBoundingClientRect();\n            const currentX = event.clientX - rect.left;\n            const currentY = event.clientY - rect.top;\n            const meta = pageMetaRef.current[activePageNumber];\n            const rects = wordRectsRef.current[activePageNumber] || [];\n            const startWordIndex = selectionStateRef.current.startWordIndex;\n            const startPageNumber = selectionStateRef.current.pageNumber;\n            if (meta && rects.length > 0 && startWordIndex !== null) {\n                var _findWordIndexAtPoint;\n                const currentWordIndex = (_findWordIndexAtPoint = findWordIndexAtPoint(rects, meta, currentX, currentY)) !== null && _findWordIndexAtPoint !== void 0 ? _findWordIndexAtPoint : findLastWordIndexBeforePoint(rects, meta, currentX, currentY);\n                if (currentWordIndex !== null) {\n                    renderHighlightsAcrossPages(startPageNumber, startWordIndex, activePageNumber, currentWordIndex, false);\n                }\n            }\n            return;\n        }\n        const meta = pageMetaRef.current[pageNumber];\n        const rects = wordRectsRef.current[pageNumber] || [];\n        if (!meta || rects.length === 0) {\n            target.style.cursor = \"default\";\n            return;\n        }\n        const rect = target.getBoundingClientRect();\n        const x = event.clientX - rect.left;\n        const y = event.clientY - rect.top;\n        const hit = rects.some((rect)=>{\n            const left = rect.left * meta.width;\n            const top = rect.top * meta.height;\n            const right = (rect.left + rect.width) * meta.width;\n            const bottom = (rect.top + rect.height) * meta.height;\n            return x >= left && x <= right && y >= top && y <= bottom;\n        });\n        target.style.cursor = hit ? \"text\" : \"default\";\n    };\n    const handlePointerLeave = (event)=>{\n        const target = event.currentTarget;\n        target.style.cursor = \"default\";\n    };\n    const handlePointerDown = (event)=>{\n        var _target_parentElement;\n        const target = event.currentTarget;\n        const pageNumber = Number((_target_parentElement = target.parentElement) === null || _target_parentElement === void 0 ? void 0 : _target_parentElement.dataset.pageNumber);\n        if (!pageNumber) return;\n        const rect = target.getBoundingClientRect();\n        const startX = event.clientX - rect.left;\n        const startY = event.clientY - rect.top;\n        target.querySelectorAll(\".pdf-embed__highlight\").forEach((node)=>node.remove());\n        if (popupRef.current) {\n            popupRef.current.remove();\n            popupRef.current = null;\n        }\n        selectionRef.current = null;\n        const meta = pageMetaRef.current[pageNumber];\n        const rects = wordRectsRef.current[pageNumber] || [];\n        const startWordIndex = meta && rects.length > 0 ? findWordIndexAtPoint(rects, meta, startX, startY) : null;\n        selectionStateRef.current = {\n            pageNumber,\n            startX,\n            startY,\n            startWordIndex\n        };\n        target.setPointerCapture(event.pointerId);\n    };\n    const handlePointerUp = (event)=>{\n        var _overlay_parentElement;\n        const target = event.currentTarget;\n        target.releasePointerCapture(event.pointerId);\n        const selection = selectionStateRef.current;\n        if (!selection) return;\n        selectionRef.current = null;\n        selectionStateRef.current = null;\n        const startPageNumber = selection.pageNumber;\n        var _getOverlayFromPoint;\n        const overlay = (_getOverlayFromPoint = getOverlayFromPoint(event.clientX, event.clientY)) !== null && _getOverlayFromPoint !== void 0 ? _getOverlayFromPoint : target;\n        var _overlay_dataset_pageNumber;\n        const endPageNumber = Number((_overlay_dataset_pageNumber = overlay.dataset.pageNumber) !== null && _overlay_dataset_pageNumber !== void 0 ? _overlay_dataset_pageNumber : (_overlay_parentElement = overlay.parentElement) === null || _overlay_parentElement === void 0 ? void 0 : _overlay_parentElement.dataset.pageNumber);\n        if (!endPageNumber) return;\n        const targetRect = overlay.getBoundingClientRect();\n        const meta = pageMetaRef.current[endPageNumber];\n        const rects = wordRectsRef.current[endPageNumber] || [];\n        if (!meta || rects.length === 0) return;\n        const currentX = event.clientX - targetRect.left;\n        const currentY = event.clientY - targetRect.top;\n        const startWordIndex = selection.startWordIndex;\n        if (startWordIndex === null) return;\n        var _findWordIndexAtPoint;\n        const currentWordIndex = (_findWordIndexAtPoint = findWordIndexAtPoint(rects, meta, currentX, currentY)) !== null && _findWordIndexAtPoint !== void 0 ? _findWordIndexAtPoint : findLastWordIndexBeforePoint(rects, meta, currentX, currentY);\n        if (currentWordIndex === null) return;\n        renderHighlightsAcrossPages(startPageNumber, startWordIndex, endPageNumber, currentWordIndex, true);\n    };\n    const renderHighlightsByIndex = (target, rects, meta, startIndex, endIndex, showPopupAfter)=>{\n        const minIndex = Math.min(startIndex, endIndex);\n        const maxIndex = Math.max(startIndex, endIndex);\n        target.querySelectorAll(\".pdf-embed__highlight\").forEach((node)=>node.remove());\n        let bounds = null;\n        const selected = rects.filter((rect)=>rect.wordIndex >= minIndex && rect.wordIndex <= maxIndex);\n        const groups = groupRectsByLine(selected);\n        for (const group of groups){\n            const left = group.left * meta.width;\n            const top = group.top * meta.height;\n            const right = (group.left + group.width) * meta.width;\n            const bottom = (group.top + group.height) * meta.height;\n            if (!bounds) {\n                bounds = {\n                    left,\n                    top,\n                    right,\n                    bottom\n                };\n            } else {\n                bounds.left = Math.min(bounds.left, left);\n                bounds.top = Math.min(bounds.top, top);\n                bounds.right = Math.max(bounds.right, right);\n                bounds.bottom = Math.max(bounds.bottom, bottom);\n            }\n            const highlight = document.createElement(\"div\");\n            highlight.className = \"pdf-embed__highlight\";\n            highlight.style.left = \"\".concat(left, \"px\");\n            highlight.style.top = \"\".concat(top, \"px\");\n            highlight.style.width = \"\".concat(right - left, \"px\");\n            highlight.style.height = \"\".concat(bottom - top, \"px\");\n            target.appendChild(highlight);\n        }\n        if (bounds && showPopupAfter) {\n            const anchor = getWordAnchor(rects, meta, endIndex);\n            showPopup(target, bounds, anchor !== null && anchor !== void 0 ? anchor : undefined);\n        }\n    };\n    const renderHighlightsAcrossPages = (startPage, startIndex, endPage, endIndex, showPopupAfter)=>{\n        clearAllHighlights();\n        const pages = Object.keys(wordRectsRef.current).map((key)=>Number(key)).filter((page)=>Number.isFinite(page)).sort((a, b)=>a - b);\n        if (pages.length === 0) return;\n        const forward = startPage <= endPage;\n        const fromPage = forward ? startPage : endPage;\n        const toPage = forward ? endPage : startPage;\n        for (const pageNumber of pages){\n            if (pageNumber < fromPage || pageNumber > toPage) continue;\n            const rects = wordRectsRef.current[pageNumber] || [];\n            const meta = pageMetaRef.current[pageNumber];\n            const overlay = getOverlayForPage(pageNumber);\n            if (!rects.length || !meta || !overlay) continue;\n            const [rangeStart, rangeEnd] = getPageSelectionRange(rects, pageNumber, startPage, startIndex, endPage, endIndex);\n            renderHighlightsByIndex(overlay, rects, meta, rangeStart, rangeEnd, false);\n        }\n        if (showPopupAfter) {\n            const targetPage = endPage;\n            const rects = wordRectsRef.current[targetPage] || [];\n            const meta = pageMetaRef.current[targetPage];\n            const overlay = getOverlayForPage(targetPage);\n            if (rects.length && meta && overlay) {\n                const [rangeStart, rangeEnd] = getPageSelectionRange(rects, targetPage, startPage, startIndex, endPage, endIndex);\n                const anchorIndex = rangeEnd;\n                const selected = rects.filter((rect)=>rect.wordIndex >= rangeStart && rect.wordIndex <= rangeEnd);\n                let bounds = null;\n                const groups = groupRectsByLine(selected);\n                for (const group of groups){\n                    const left = group.left * meta.width;\n                    const top = group.top * meta.height;\n                    const right = (group.left + group.width) * meta.width;\n                    const bottom = (group.top + group.height) * meta.height;\n                    if (!bounds) {\n                        bounds = {\n                            left,\n                            top,\n                            right,\n                            bottom\n                        };\n                    } else {\n                        bounds.left = Math.min(bounds.left, left);\n                        bounds.top = Math.min(bounds.top, top);\n                        bounds.right = Math.max(bounds.right, right);\n                        bounds.bottom = Math.max(bounds.bottom, bottom);\n                    }\n                }\n                if (bounds) {\n                    const anchor = getWordAnchor(rects, meta, anchorIndex);\n                    showPopup(overlay, bounds, anchor !== null && anchor !== void 0 ? anchor : undefined);\n                }\n            }\n        }\n    };\n    const showPopup = (target, bounds, anchor)=>{\n        if (popupRef.current) {\n            popupRef.current.remove();\n            popupRef.current = null;\n        }\n        const popup = document.createElement(\"div\");\n        popup.className = \"pdf-embed__popup\";\n        popup.innerHTML = '\\n      <div class=\"pdf-embed__popup-palette\" aria-label=\"Highlight colors\">\\n        <button type=\"button\" class=\"pdf-embed__palette-color is-selected\" style=\"--swatch:#ffd84d\">\\n          <span class=\"pdf-embed__palette-check\">✓</span>\\n        </button>\\n        <button type=\"button\" class=\"pdf-embed__palette-color\" style=\"--swatch:#ffb347\"></button>\\n        <button type=\"button\" class=\"pdf-embed__palette-color\" style=\"--swatch:#ff7b7b\"></button>\\n        <button type=\"button\" class=\"pdf-embed__palette-color\" style=\"--swatch:#ff8bd1\"></button>\\n        <button type=\"button\" class=\"pdf-embed__palette-color\" style=\"--swatch:#b28cff\"></button>\\n        <button type=\"button\" class=\"pdf-embed__palette-color\" style=\"--swatch:#7aa9ff\"></button>\\n        <button type=\"button\" class=\"pdf-embed__palette-color\" style=\"--swatch:#69d2ff\"></button>\\n        <button type=\"button\" class=\"pdf-embed__palette-color\" style=\"--swatch:#65e0a1\"></button>\\n        <button type=\"button\" class=\"pdf-embed__palette-color\" style=\"--swatch:#c7ea6b\"></button>\\n        <button type=\"button\" class=\"pdf-embed__palette-color\" style=\"--swatch:#ffe4a3\"></button>\\n      </div>\\n      <button type=\"button\" class=\"pdf-embed__popup-btn\">\\n        <svg class=\"pdf-embed__popup-icon\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\\n          <g transform=\"translate(12 12) scale(1.1) translate(-12 -12)\">\\n            <path\\n              d=\"M4 16.5V20h3.5L18.8 8.7l-3.5-3.5L4 16.5z\"\\n              fill=\"none\"\\n              stroke=\"currentColor\"\\n              stroke-width=\"2\"\\n              stroke-linejoin=\"round\"\\n            />\\n            <path\\n              d=\"M13.8 5.2l3.5 3.5\"\\n              fill=\"none\"\\n              stroke=\"currentColor\"\\n              stroke-width=\"2\"\\n              stroke-linecap=\"round\"\\n            />\\n          </g>\\n        </svg>\\n        Highlight\\n        <span class=\"pdf-embed__popup-shortcut\">\\n          <span class=\"pdf-embed__popup-key\">⌘</span>\\n          <span class=\"pdf-embed__popup-key\">H</span>\\n        </span>\\n      </button>\\n      <button type=\"button\" class=\"pdf-embed__popup-btn\">\\n        <svg class=\"pdf-embed__popup-icon\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\\n          <g transform=\"translate(12 12) scale(1.1) translate(-12 -12)\">\\n            <path\\n              d=\"M8 4v7a4 4 0 0 0 8 0V4\"\\n              fill=\"none\"\\n              stroke=\"currentColor\"\\n              stroke-width=\"2\"\\n              stroke-linecap=\"round\"\\n            />\\n            <path\\n              d=\"M5 20h14\"\\n              fill=\"none\"\\n              stroke=\"currentColor\"\\n              stroke-width=\"2\"\\n              stroke-linecap=\"round\"\\n            />\\n          </g>\\n        </svg>\\n        Underline\\n        <span class=\"pdf-embed__popup-shortcut\">\\n          <span class=\"pdf-embed__popup-key\">⌘</span>\\n          <span class=\"pdf-embed__popup-key\">U</span>\\n        </span>\\n      </button>\\n      <button type=\"button\" class=\"pdf-embed__popup-btn\">\\n        <svg class=\"pdf-embed__popup-icon\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\\n          <g transform=\"translate(12 12) scale(1.1) translate(-12 -12)\">\\n            <rect\\n              x=\"8\"\\n              y=\"8\"\\n              width=\"10\"\\n              height=\"10\"\\n              rx=\"2\"\\n              fill=\"none\"\\n              stroke=\"currentColor\"\\n              stroke-width=\"2\"\\n            />\\n            <path\\n              d=\"M6 16H5a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1\"\\n              fill=\"none\"\\n              stroke=\"currentColor\"\\n              stroke-width=\"2\"\\n              stroke-linecap=\"round\"\\n            />\\n          </g>\\n        </svg>\\n        Copy\\n        <span class=\"pdf-embed__popup-shortcut\">\\n          <span class=\"pdf-embed__popup-key\">⌘</span>\\n          <span class=\"pdf-embed__popup-key\">C</span>\\n        </span>\\n      </button>\\n      <button type=\"button\" class=\"pdf-embed__popup-btn\">\\n        <svg class=\"pdf-embed__popup-icon\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\\n          <g transform=\"translate(12 12) scale(1.1) translate(-12 -12)\">\\n            <path\\n              d=\"M4 8a3 3 0 0 1 3-3h10a3 3 0 0 1 3 3v6a3 3 0 0 1-3 3H9l-4 3v-3H7a3 3 0 0 1-3-3V8z\"\\n              fill=\"none\"\\n              stroke=\"currentColor\"\\n              stroke-width=\"2\"\\n              stroke-linejoin=\"round\"\\n            />\\n            <path\\n              d=\"M12 9v6M9 12h6\"\\n              fill=\"none\"\\n              stroke=\"currentColor\"\\n              stroke-width=\"2\"\\n              stroke-linecap=\"round\"\\n            />\\n          </g>\\n        </svg>\\n        Add to chat\\n        <span class=\"pdf-embed__popup-shortcut\">\\n          <span class=\"pdf-embed__popup-key\">⌘</span>\\n          <span class=\"pdf-embed__popup-key\">A</span>\\n        </span>\\n      </button>\\n    ';\n        target.appendChild(popup);\n        const { width: popupWidth, height: popupHeight } = popup.getBoundingClientRect();\n        const maxLeft = Math.max(6, target.clientWidth - popupWidth - 6);\n        const maxTop = Math.max(6, target.clientHeight - popupHeight - 6);\n        const anchorX = anchor ? anchor.x : bounds.right;\n        const anchorY = anchor ? anchor.y : bounds.bottom;\n        const left = Math.max(6, Math.min(anchorX + 8, maxLeft));\n        const top = Math.max(6, Math.min(anchorY + 8, maxTop));\n        popup.style.left = \"\".concat(left, \"px\");\n        popup.style.top = \"\".concat(top, \"px\");\n        popupRef.current = popup;\n    };\n    const getWordAnchor = (rects, meta, wordIndex)=>{\n        const rect = rects.find((item)=>item.wordIndex === wordIndex);\n        if (!rect) return null;\n        return {\n            x: (rect.left + rect.width) * meta.width,\n            y: (rect.top + rect.height) * meta.height\n        };\n    };\n    const getPageSelectionRange = (rects, pageNumber, startPage, startIndex, endPage, endIndex)=>{\n        const firstIndex = rects[0].wordIndex;\n        const lastIndex = rects[rects.length - 1].wordIndex;\n        if (startPage === endPage) {\n            return [\n                Math.min(startIndex, endIndex),\n                Math.max(startIndex, endIndex)\n            ];\n        }\n        if (startPage < endPage) {\n            if (pageNumber === startPage) return [\n                startIndex,\n                lastIndex\n            ];\n            if (pageNumber === endPage) return [\n                firstIndex,\n                endIndex\n            ];\n            return [\n                firstIndex,\n                lastIndex\n            ];\n        }\n        if (pageNumber === startPage) return [\n            firstIndex,\n            startIndex\n        ];\n        if (pageNumber === endPage) return [\n            endIndex,\n            lastIndex\n        ];\n        return [\n            firstIndex,\n            lastIndex\n        ];\n    };\n    const clearAllHighlights = ()=>{\n        if (!containerRef.current) return;\n        containerRef.current.querySelectorAll(\".pdf-embed__highlight\").forEach((node)=>node.remove());\n    };\n    const getOverlayForPage = (pageNumber)=>{\n        if (!containerRef.current) return null;\n        return containerRef.current.querySelector('.pdf-embed__overlay[data-page-number=\"'.concat(pageNumber, '\"]'));\n    };\n    const getOverlayFromPoint = (x, y)=>{\n        const element = document.elementFromPoint(x, y);\n        if (!element) return null;\n        return element.closest(\".pdf-embed__overlay\");\n    };\n    const groupRectsByLine = (rects)=>{\n        if (rects.length === 0) return [];\n        const sorted = [\n            ...rects\n        ].sort((a, b)=>{\n            var _a_lineId, _b_lineId;\n            return ((_a_lineId = a.lineId) !== null && _a_lineId !== void 0 ? _a_lineId : 0) - ((_b_lineId = b.lineId) !== null && _b_lineId !== void 0 ? _b_lineId : 0) || a.top - b.top || a.left - b.left;\n        });\n        const groups = [];\n        let current = {\n            ...sorted[0]\n        };\n        for(let i = 1; i < sorted.length; i += 1){\n            const rect = sorted[i];\n            const sameLine = rect.lineId !== null && rect.lineId === current.lineId;\n            if (sameLine) {\n                const newLeft = Math.min(current.left, rect.left);\n                const newRight = Math.max(current.left + current.width, rect.left + rect.width);\n                current.left = newLeft;\n                current.width = newRight - newLeft;\n                current.height = Math.max(current.height, rect.height);\n            } else {\n                groups.push(current);\n                current = {\n                    ...rect\n                };\n            }\n        }\n        groups.push(current);\n        return groups;\n    };\n    const findWordIndexAtPoint = (rects, meta, x, y)=>{\n        for (const rectItem of rects){\n            const left = rectItem.left * meta.width;\n            const top = rectItem.top * meta.height;\n            const right = (rectItem.left + rectItem.width) * meta.width;\n            const bottom = (rectItem.top + rectItem.height) * meta.height;\n            if (x >= left && x <= right && y >= top && y <= bottom) {\n                return rectItem.wordIndex;\n            }\n        }\n        return null;\n    };\n    const findLastWordIndexBeforePoint = (rects, meta, x, y)=>{\n        let bestIndex = null;\n        for (const rectItem of rects){\n            const left = rectItem.left * meta.width;\n            const top = rectItem.top * meta.height;\n            const right = (rectItem.left + rectItem.width) * meta.width;\n            const bottom = (rectItem.top + rectItem.height) * meta.height;\n            const centerX = (left + right) / 2;\n            const centerY = (top + bottom) / 2;\n            if (centerY <= y && centerX <= x) {\n                if (bestIndex === null || rectItem.wordIndex > bestIndex) {\n                    bestIndex = rectItem.wordIndex;\n                }\n            }\n        }\n        return bestIndex;\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"pdf-embed\",\n        children: [\n            state === \"loading\" ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"empty-state\",\n                children: \"PDFを読み込み中...\"\n            }, void 0, false, {\n                fileName: \"/Users/programs/ask-pdf/apps/web/src/components/pdf-viewer/pdf-viewer.tsx\",\n                lineNumber: 777,\n                columnNumber: 9\n            }, this) : null,\n            state === \"error\" ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"empty-state\",\n                children: [\n                    \"PDFの表示に失敗しました\",\n                    errorMessage ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"pdf-embed__error\",\n                        children: errorMessage\n                    }, void 0, false, {\n                        fileName: \"/Users/programs/ask-pdf/apps/web/src/components/pdf-viewer/pdf-viewer.tsx\",\n                        lineNumber: 782,\n                        columnNumber: 27\n                    }, this) : null\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/programs/ask-pdf/apps/web/src/components/pdf-viewer/pdf-viewer.tsx\",\n                lineNumber: 780,\n                columnNumber: 9\n            }, this) : null,\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: containerRef,\n                className: \"pdf-embed__pages\"\n            }, void 0, false, {\n                fileName: \"/Users/programs/ask-pdf/apps/web/src/components/pdf-viewer/pdf-viewer.tsx\",\n                lineNumber: 785,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/programs/ask-pdf/apps/web/src/components/pdf-viewer/pdf-viewer.tsx\",\n        lineNumber: 775,\n        columnNumber: 5\n    }, this);\n}\n_s(PdfViewer, \"hh2bNADN+bRpRSBQPtZOXKaEMVM=\");\n_c = PdfViewer;\nvar _c;\n$RefreshReg$(_c, \"PdfViewer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3BkZi12aWV3ZXIvcGRmLXZpZXdlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRW9EO0FBMEI3QyxTQUFTRyxVQUFVLEtBQWdEO1FBQWhELEVBQUVDLEdBQUcsRUFBRUMsVUFBVSxFQUFFQyxXQUFXLEVBQWtCLEdBQWhEOztJQUN4QixNQUFNQyxlQUFlTiw2Q0FBTUEsQ0FBd0I7SUFDbkQsTUFBTSxDQUFDTyxPQUFPQyxTQUFTLEdBQUdQLCtDQUFRQSxDQUFjO0lBQ2hELE1BQU0sQ0FBQ1EsY0FBY0MsZ0JBQWdCLEdBQUdULCtDQUFRQSxDQUFnQjtJQUNoRSxNQUFNLENBQUNVLFVBQVVDLFlBQVksR0FBR1gsK0NBQVFBLENBQTJCLENBQUM7SUFDcEUsTUFBTVksY0FBY2IsNkNBQU1BLENBQTJCLENBQUM7SUFDdEQsTUFBTSxDQUFDYyxnQkFBZ0JDLGtCQUFrQixHQUFHZCwrQ0FBUUEsQ0FDbEQ7SUFFRixNQUFNZSxlQUFlaEIsNkNBQU1BLENBQTZCLENBQUM7SUFDekQsTUFBTWlCLGVBQWVqQiw2Q0FBTUEsQ0FBd0I7SUFDbkQsTUFBTWtCLFdBQVdsQiw2Q0FBTUEsQ0FBd0I7SUFDL0MsTUFBTW1CLG9CQUFvQm5CLDZDQUFNQSxDQUt0QjtJQUVWRCxnREFBU0EsQ0FBQztRQUNSLElBQUlxQixZQUFZO1FBQ2hCLE1BQU1DLFNBQVM7WUFDYmIsU0FBUztZQUNURSxnQkFBZ0I7WUFDaEIsTUFBTVksWUFBWWhCLGFBQWFpQixPQUFPO1lBQ3RDLElBQUksQ0FBQ0QsV0FBVztZQUNoQkEsVUFBVUUsU0FBUyxHQUFHO1lBQ3RCLElBQUk7Z0JBQ0YsTUFBTUMsUUFBUSxNQUFNLHFRQUFxQztnQkFDekRBLE1BQU1DLG1CQUFtQixDQUFDQyxTQUFTLEdBQUc7Z0JBQ3RDLE1BQU1DLGNBQWNILE1BQU1JLFdBQVcsQ0FBQztvQkFBRTFCO2dCQUFJO2dCQUM1QyxNQUFNMkIsTUFBTSxNQUFNRixZQUFZRyxP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Ozs7Ozt1QkFFM0U7MEJBQ0osOERBQUN1TjtnQkFBSUUsS0FBSzVOO2dCQUFjNEMsV0FBVTs7Ozs7Ozs7Ozs7O0FBR3hDO0dBdnZCZ0JoRDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9wZGYtdmlld2VyL3BkZi12aWV3ZXIudHN4P2RhYjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG50eXBlIFBkZlZpZXdlclByb3BzID0ge1xuICB1cmw6IHN0cmluZztcbiAgZG9jdW1lbnRJZDogc3RyaW5nIHwgbnVsbDtcbiAgYWNjZXNzVG9rZW46IHN0cmluZyB8IG51bGw7XG59O1xuXG50eXBlIFJlbmRlclN0YXRlID0gXCJpZGxlXCIgfCBcImxvYWRpbmdcIiB8IFwiZXJyb3JcIjtcblxudHlwZSBQYWdlTWV0YSA9IHtcbiAgd2lkdGg6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIHdpZHRoSW5jaDogbnVtYmVyO1xuICBoZWlnaHRJbmNoOiBudW1iZXI7XG59O1xuXG50eXBlIFdvcmRSZWN0ID0ge1xuICB3b3JkSW5kZXg6IG51bWJlcjtcbiAgbGluZUlkOiBudW1iZXIgfCBudWxsO1xuICBsZWZ0OiBudW1iZXI7XG4gIHRvcDogbnVtYmVyO1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBQZGZWaWV3ZXIoeyB1cmwsIGRvY3VtZW50SWQsIGFjY2Vzc1Rva2VuIH06IFBkZlZpZXdlclByb3BzKSB7XG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPFJlbmRlclN0YXRlPihcImlkbGVcIik7XG4gIGNvbnN0IFtlcnJvck1lc3NhZ2UsIHNldEVycm9yTWVzc2FnZV0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3BhZ2VNZXRhLCBzZXRQYWdlTWV0YV0gPSB1c2VTdGF0ZTxSZWNvcmQ8bnVtYmVyLCBQYWdlTWV0YT4+KHt9KTtcbiAgY29uc3QgcGFnZU1ldGFSZWYgPSB1c2VSZWY8UmVjb3JkPG51bWJlciwgUGFnZU1ldGE+Pih7fSk7XG4gIGNvbnN0IFtkb2N1bWVudFJlc3VsdCwgc2V0RG9jdW1lbnRSZXN1bHRdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBudWxsPihcbiAgICBudWxsXG4gICk7XG4gIGNvbnN0IHdvcmRSZWN0c1JlZiA9IHVzZVJlZjxSZWNvcmQ8bnVtYmVyLCBXb3JkUmVjdFtdPj4oe30pO1xuICBjb25zdCBzZWxlY3Rpb25SZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgcG9wdXBSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQgfCBudWxsPihudWxsKTtcbiAgY29uc3Qgc2VsZWN0aW9uU3RhdGVSZWYgPSB1c2VSZWY8e1xuICAgIHBhZ2VOdW1iZXI6IG51bWJlcjtcbiAgICBzdGFydFg6IG51bWJlcjtcbiAgICBzdGFydFk6IG51bWJlcjtcbiAgICBzdGFydFdvcmRJbmRleDogbnVtYmVyIHwgbnVsbDtcbiAgfSB8IG51bGw+KG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHJlbmRlciA9IGFzeW5jICgpID0+IHtcbiAgICAgIHNldFN0YXRlKFwibG9hZGluZ1wiKTtcbiAgICAgIHNldEVycm9yTWVzc2FnZShudWxsKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgaWYgKCFjb250YWluZXIpIHJldHVybjtcbiAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGRmanMgPSBhd2FpdCBpbXBvcnQoXCJwZGZqcy1kaXN0L2xlZ2FjeS9idWlsZC9wZGZcIik7XG4gICAgICAgIHBkZmpzLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjID0gXCIvcGRmLndvcmtlci5taW4ubWpzXCI7XG4gICAgICAgIGNvbnN0IGxvYWRpbmdUYXNrID0gcGRmanMuZ2V0RG9jdW1lbnQoeyB1cmwgfSk7XG4gICAgICAgIGNvbnN0IHBkZiA9IGF3YWl0IGxvYWRpbmdUYXNrLnByb21pc2U7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgY29udGFpbmVyV2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGggfHwgNzIwO1xuXG4gICAgICAgIGNvbnN0IG5leHRNZXRhOiBSZWNvcmQ8bnVtYmVyLCBQYWdlTWV0YT4gPSB7fTtcbiAgICAgICAgZm9yIChsZXQgcGFnZU51bSA9IDE7IHBhZ2VOdW0gPD0gcGRmLm51bVBhZ2VzOyBwYWdlTnVtICs9IDEpIHtcbiAgICAgICAgICBjb25zdCBwYWdlID0gYXdhaXQgcGRmLmdldFBhZ2UocGFnZU51bSk7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGU6IDEgfSk7XG4gICAgICAgICAgY29uc3QgcGFnZVdpZHRoID0gTWF0aC5taW4oY29udGFpbmVyV2lkdGgsIDkwMCk7XG4gICAgICAgICAgY29uc3Qgc2NhbGUgPSBwYWdlV2lkdGggLyB2aWV3cG9ydC53aWR0aDtcbiAgICAgICAgICBjb25zdCBzY2FsZWQgPSBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGUgfSk7XG5cbiAgICAgICAgICBjb25zdCBwYWdlV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgcGFnZVdyYXBwZXIuY2xhc3NOYW1lID0gXCJwZGYtZW1iZWRfX3BhZ2VcIjtcbiAgICAgICAgICBwYWdlV3JhcHBlci5kYXRhc2V0LnBhZ2VOdW1iZXIgPSBTdHJpbmcocGFnZU51bSk7XG4gICAgICAgICAgcGFnZVdyYXBwZXIuc3R5bGUud2lkdGggPSBgJHtNYXRoLmZsb29yKHNjYWxlZC53aWR0aCl9cHhgO1xuICAgICAgICAgIHBhZ2VXcmFwcGVyLnN0eWxlLm1hcmdpbiA9IFwiMCBhdXRvXCI7XG5cbiAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSBcInBkZi1lbWJlZF9fY2FudmFzXCI7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gTWF0aC5mbG9vcihzY2FsZWQud2lkdGgpO1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKHNjYWxlZC5oZWlnaHQpO1xuXG4gICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgb3ZlcmxheS5jbGFzc05hbWUgPSBcInBkZi1lbWJlZF9fb3ZlcmxheVwiO1xuICAgICAgICAgIG92ZXJsYXkuc3R5bGUud2lkdGggPSBgJHtNYXRoLmZsb29yKHNjYWxlZC53aWR0aCl9cHhgO1xuICAgICAgICAgIG92ZXJsYXkuc3R5bGUuaGVpZ2h0ID0gYCR7TWF0aC5mbG9vcihzY2FsZWQuaGVpZ2h0KX1weGA7XG4gICAgICAgICAgb3ZlcmxheS5kYXRhc2V0LnBhZ2VOdW1iZXIgPSBTdHJpbmcocGFnZU51bSk7XG4gICAgICAgICAgb3ZlcmxheS5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgaGFuZGxlUG9pbnRlck1vdmUpO1xuICAgICAgICAgIG92ZXJsYXkuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCBoYW5kbGVQb2ludGVyTGVhdmUpO1xuICAgICAgICAgIG92ZXJsYXkuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgICBvdmVybGF5LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgaGFuZGxlUG9pbnRlclVwKTtcbiAgICAgICAgICBvdmVybGF5LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocG9wdXBSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICBwb3B1cFJlZi5jdXJyZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgICBwb3B1cFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHBhZ2VXcmFwcGVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICAgICAgcGFnZVdyYXBwZXIuYXBwZW5kQ2hpbGQob3ZlcmxheSk7XG4gICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHBhZ2VXcmFwcGVyKTtcblxuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgIGlmICghY29udGV4dCkgY29udGludWU7XG4gICAgICAgICAgYXdhaXQgcGFnZS5yZW5kZXIoeyBjYW52YXNDb250ZXh0OiBjb250ZXh0LCB2aWV3cG9ydDogc2NhbGVkIH0pLnByb21pc2U7XG5cbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHBhZ2VNZXRhUmVmLmN1cnJlbnRbcGFnZU51bV07XG4gICAgICAgICAgbmV4dE1ldGFbcGFnZU51bV0gPSB7XG4gICAgICAgICAgICB3aWR0aDogTWF0aC5mbG9vcihzY2FsZWQud2lkdGgpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLmZsb29yKHNjYWxlZC5oZWlnaHQpLFxuICAgICAgICAgICAgd2lkdGhJbmNoOlxuICAgICAgICAgICAgICBleGlzdGluZz8ud2lkdGhJbmNoICYmIGV4aXN0aW5nLndpZHRoSW5jaCA+IDBcbiAgICAgICAgICAgICAgICA/IGV4aXN0aW5nLndpZHRoSW5jaFxuICAgICAgICAgICAgICAgIDogdmlld3BvcnQud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHRJbmNoOlxuICAgICAgICAgICAgICBleGlzdGluZz8uaGVpZ2h0SW5jaCAmJiBleGlzdGluZy5oZWlnaHRJbmNoID4gMFxuICAgICAgICAgICAgICAgID8gZXhpc3RpbmcuaGVpZ2h0SW5jaFxuICAgICAgICAgICAgICAgIDogdmlld3BvcnQuaGVpZ2h0LFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNhbmNlbGxlZCkge1xuICAgICAgICAgIHNldFBhZ2VNZXRhKG5leHRNZXRhKTtcbiAgICAgICAgICBzZXRTdGF0ZShcImlkbGVcIik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmICghY2FuY2VsbGVkKSB7XG4gICAgICAgICAgc2V0U3RhdGUoXCJlcnJvclwiKTtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJQREbjgpLooajnpLrjgafjgY3jgb7jgZvjgpPjgafjgZfjgZ9cIjtcbiAgICAgICAgICBzZXRFcnJvck1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdm9pZCByZW5kZXIoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgIGlmIChjb250YWluZXJSZWYuY3VycmVudCkge1xuICAgICAgICBjb250YWluZXJSZWYuY3VycmVudC5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFt1cmxdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHBhZ2VNZXRhUmVmLmN1cnJlbnQgPSBwYWdlTWV0YTtcbiAgfSwgW3BhZ2VNZXRhXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBsb2FkUmVzdWx0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCFkb2N1bWVudElkIHx8ICFhY2Nlc3NUb2tlbikge1xuICAgICAgICBzZXREb2N1bWVudFJlc3VsdChudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9CQVNFX1VSTCA/PyBcImh0dHA6Ly8xMjcuMC4wLjE6ODAwMFwiO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2Jhc2VVcmx9L2RvY3VtZW50cy8ke2RvY3VtZW50SWR9L3Jlc3VsdGAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykgcmV0dXJuO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHNldERvY3VtZW50UmVzdWx0KHJlc3VsdCk7XG4gICAgICAgIGNvbnN0IHBhZ2VzID0gQXJyYXkuaXNBcnJheShyZXN1bHQucGFnZXMpID8gcmVzdWx0LnBhZ2VzIDogW107XG4gICAgICAgIGlmIChwYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc2V0UGFnZU1ldGEoKHByZXYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IHsgLi4ucHJldiB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYWdlIG9mIHBhZ2VzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhZ2VOdW1iZXIgPSBOdW1iZXIocGFnZS5wYWdlTnVtYmVyID8/IHBhZ2UucGFnZV9udW1iZXIpO1xuICAgICAgICAgICAgICBpZiAoIXBhZ2VOdW1iZXIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjb25zdCB3aWR0aEluY2ggPSBOdW1iZXIocGFnZS53aWR0aCA/PyBwYWdlLndpZHRoSW5jaCk7XG4gICAgICAgICAgICAgIGNvbnN0IGhlaWdodEluY2ggPSBOdW1iZXIocGFnZS5oZWlnaHQgPz8gcGFnZS5oZWlnaHRJbmNoKTtcbiAgICAgICAgICAgICAgbWVyZ2VkW3BhZ2VOdW1iZXJdID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBwcmV2W3BhZ2VOdW1iZXJdPy53aWR0aCA/PyAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcHJldltwYWdlTnVtYmVyXT8uaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgd2lkdGhJbmNoOiBOdW1iZXIuaXNGaW5pdGUod2lkdGhJbmNoKSA/IHdpZHRoSW5jaCA6IHByZXZbcGFnZU51bWJlcl0/LndpZHRoSW5jaCA/PyAwLFxuICAgICAgICAgICAgICAgIGhlaWdodEluY2g6IE51bWJlci5pc0Zpbml0ZShoZWlnaHRJbmNoKSA/IGhlaWdodEluY2ggOiBwcmV2W3BhZ2VOdW1iZXJdPy5oZWlnaHRJbmNoID8/IDAsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV4dFJlY3RzOiBSZWNvcmQ8bnVtYmVyLCBXb3JkUmVjdFtdPiA9IHt9O1xuXG4gICAgICAgIGNvbnN0IHBvbHlnb25Ub1JlY3QgPSAocG9seWdvbjogbnVtYmVyW10pID0+IHtcbiAgICAgICAgICBjb25zdCB4cyA9IFtdO1xuICAgICAgICAgIGNvbnN0IHlzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB4cy5wdXNoKHBvbHlnb25baV0pO1xuICAgICAgICAgICAgeXMucHVzaChwb2x5Z29uW2kgKyAxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGxlZnQgPSBNYXRoLm1pbiguLi54cyk7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSBNYXRoLm1heCguLi54cyk7XG4gICAgICAgICAgY29uc3QgdG9wID0gTWF0aC5taW4oLi4ueXMpO1xuICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IE1hdGgubWF4KC4uLnlzKTtcbiAgICAgICAgICByZXR1cm4geyBsZWZ0LCB0b3AsIHdpZHRoOiByaWdodCAtIGxlZnQsIGhlaWdodDogYm90dG9tIC0gdG9wIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChjb25zdCBwYWdlIG9mIHBhZ2VzKSB7XG4gICAgICAgICAgY29uc3QgcGFnZU51bWJlciA9IE51bWJlcihwYWdlLnBhZ2VOdW1iZXIgPz8gcGFnZS5wYWdlX251bWJlcik7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBOdW1iZXIocGFnZS53aWR0aCA/PyBwYWdlLndpZHRoSW5jaCk7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gTnVtYmVyKHBhZ2UuaGVpZ2h0ID8/IHBhZ2UuaGVpZ2h0SW5jaCk7XG4gICAgICAgICAgaWYgKCFwYWdlTnVtYmVyIHx8ICFOdW1iZXIuaXNGaW5pdGUod2lkdGgpIHx8ICFOdW1iZXIuaXNGaW5pdGUoaGVpZ2h0KSkgY29udGludWU7XG4gICAgICAgICAgY29uc3Qgd29yZHMgPSBBcnJheS5pc0FycmF5KHBhZ2Uud29yZHMpID8gcGFnZS53b3JkcyA6IFtdO1xuICAgICAgICAgIGNvbnN0IGxpbmVzID0gQXJyYXkuaXNBcnJheShwYWdlLmxpbmVzKSA/IHBhZ2UubGluZXMgOiBbXTtcbiAgICAgICAgICBjb25zdCB3b3JkVG9MaW5lID0gbmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKTtcbiAgICAgICAgICBsaW5lcy5mb3JFYWNoKChsaW5lLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhlcyA9IEFycmF5LmlzQXJyYXkobGluZS53b3JkX2luZGV4ZXMpXG4gICAgICAgICAgICAgID8gbGluZS53b3JkX2luZGV4ZXNcbiAgICAgICAgICAgICAgOiBBcnJheS5pc0FycmF5KGxpbmUud29yZEluZGV4ZXMpXG4gICAgICAgICAgICAgICAgPyBsaW5lLndvcmRJbmRleGVzXG4gICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd29yZEluZGV4IG9mIGluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh3b3JkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgd29yZFRvTGluZS5zZXQoTnVtYmVyKHdvcmRJbmRleCksIGluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAoY29uc3Qgd29yZCBvZiB3b3Jkcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdvcmQucG9seWdvbikpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHBvbHlnb25Ub1JlY3Qod29yZC5wb2x5Z29uKTtcbiAgICAgICAgICAgIGNvbnN0IHdvcmRJbmRleCA9IE51bWJlcih3b3JkLndvcmRfaW5kZXggPz8gd29yZC53b3JkSW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUod29yZEluZGV4KSkgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVkID0gKCgpID0+IHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhlcyA9IEFycmF5LmlzQXJyYXkobGluZS53b3JkX2luZGV4ZXMpXG4gICAgICAgICAgICAgICAgICA/IGxpbmUud29yZF9pbmRleGVzXG4gICAgICAgICAgICAgICAgICA6IEFycmF5LmlzQXJyYXkobGluZS53b3JkSW5kZXhlcylcbiAgICAgICAgICAgICAgICAgICAgPyBsaW5lLndvcmRJbmRleGVzXG4gICAgICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ZXMuaW5jbHVkZXMod29yZEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpbmUucG9seWdvbikpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgY29uc3QgbGluZVJlY3QgPSBwb2x5Z29uVG9SZWN0KGxpbmUucG9seWdvbik7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IGxpbmVSZWN0LnRvcCAvIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBsaW5lUmVjdC5oZWlnaHQgLyBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBpZiAoIW5leHRSZWN0c1twYWdlTnVtYmVyXSkgbmV4dFJlY3RzW3BhZ2VOdW1iZXJdID0gW107XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0ge1xuICAgICAgICAgICAgICB3b3JkSW5kZXgsXG4gICAgICAgICAgICAgIGxpbmVJZDogd29yZFRvTGluZS5nZXQod29yZEluZGV4KSA/PyBudWxsLFxuICAgICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLyB3aWR0aCxcbiAgICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAvIGhlaWdodCxcbiAgICAgICAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGggLyB3aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCAvIGhlaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICBub3JtYWxpemVkLnRvcCA9IG1hdGNoZWQudG9wO1xuICAgICAgICAgICAgICBub3JtYWxpemVkLmhlaWdodCA9IG1hdGNoZWQuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dFJlY3RzW3BhZ2VOdW1iZXJdLnB1c2gobm9ybWFsaXplZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG5leHRSZWN0cykpIHtcbiAgICAgICAgICBuZXh0UmVjdHNbTnVtYmVyKGtleSldLnNvcnQoKGEsIGIpID0+IGEud29yZEluZGV4IC0gYi53b3JkSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmRSZWN0c1JlZi5jdXJyZW50ID0gbmV4dFJlY3RzO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHNldERvY3VtZW50UmVzdWx0KG51bGwpO1xuICAgICAgfVxuICAgIH07XG4gICAgdm9pZCBsb2FkUmVzdWx0KCk7XG4gIH0sIFtkb2N1bWVudElkLCBhY2Nlc3NUb2tlbl0pO1xuXG4gIGNvbnN0IGhhbmRsZVBvaW50ZXJNb3ZlID0gKGV2ZW50OiBQb2ludGVyRXZlbnQpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxEaXZFbGVtZW50O1xuICAgIGNvbnN0IHBhZ2VOdW1iZXIgPSBOdW1iZXIodGFyZ2V0LmRhdGFzZXQucGFnZU51bWJlciA/PyB0YXJnZXQucGFyZW50RWxlbWVudD8uZGF0YXNldC5wYWdlTnVtYmVyKTtcbiAgICBpZiAoIXBhZ2VOdW1iZXIpIHJldHVybjtcbiAgICBpZiAoc2VsZWN0aW9uU3RhdGVSZWYuY3VycmVudCkge1xuICAgICAgY29uc3Qgb3ZlcmxheSA9IGdldE92ZXJsYXlGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSkgPz8gdGFyZ2V0O1xuICAgICAgY29uc3QgYWN0aXZlUGFnZU51bWJlciA9IE51bWJlcihcbiAgICAgICAgb3ZlcmxheS5kYXRhc2V0LnBhZ2VOdW1iZXIgPz8gb3ZlcmxheS5wYXJlbnRFbGVtZW50Py5kYXRhc2V0LnBhZ2VOdW1iZXJcbiAgICAgICk7XG4gICAgICBpZiAoIWFjdGl2ZVBhZ2VOdW1iZXIpIHJldHVybjtcbiAgICAgIGNvbnN0IHJlY3QgPSBvdmVybGF5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY3VycmVudFggPSBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgY29uc3QgY3VycmVudFkgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgICBjb25zdCBtZXRhID0gcGFnZU1ldGFSZWYuY3VycmVudFthY3RpdmVQYWdlTnVtYmVyXTtcbiAgICAgIGNvbnN0IHJlY3RzID0gd29yZFJlY3RzUmVmLmN1cnJlbnRbYWN0aXZlUGFnZU51bWJlcl0gfHwgW107XG4gICAgICBjb25zdCBzdGFydFdvcmRJbmRleCA9IHNlbGVjdGlvblN0YXRlUmVmLmN1cnJlbnQuc3RhcnRXb3JkSW5kZXg7XG4gICAgICBjb25zdCBzdGFydFBhZ2VOdW1iZXIgPSBzZWxlY3Rpb25TdGF0ZVJlZi5jdXJyZW50LnBhZ2VOdW1iZXI7XG4gICAgICBpZiAobWV0YSAmJiByZWN0cy5sZW5ndGggPiAwICYmIHN0YXJ0V29yZEluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRXb3JkSW5kZXggPVxuICAgICAgICAgIGZpbmRXb3JkSW5kZXhBdFBvaW50KHJlY3RzLCBtZXRhLCBjdXJyZW50WCwgY3VycmVudFkpID8/XG4gICAgICAgICAgZmluZExhc3RXb3JkSW5kZXhCZWZvcmVQb2ludChyZWN0cywgbWV0YSwgY3VycmVudFgsIGN1cnJlbnRZKTtcbiAgICAgICAgaWYgKGN1cnJlbnRXb3JkSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICByZW5kZXJIaWdobGlnaHRzQWNyb3NzUGFnZXMoXG4gICAgICAgICAgICBzdGFydFBhZ2VOdW1iZXIsXG4gICAgICAgICAgICBzdGFydFdvcmRJbmRleCxcbiAgICAgICAgICAgIGFjdGl2ZVBhZ2VOdW1iZXIsXG4gICAgICAgICAgICBjdXJyZW50V29yZEluZGV4LFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGEgPSBwYWdlTWV0YVJlZi5jdXJyZW50W3BhZ2VOdW1iZXJdO1xuICAgIGNvbnN0IHJlY3RzID0gd29yZFJlY3RzUmVmLmN1cnJlbnRbcGFnZU51bWJlcl0gfHwgW107XG4gICAgaWYgKCFtZXRhIHx8IHJlY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGFyZ2V0LnN0eWxlLmN1cnNvciA9IFwiZGVmYXVsdFwiO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHggPSBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgIGNvbnN0IHkgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgY29uc3QgaGl0ID0gcmVjdHMuc29tZSgocmVjdCkgPT4ge1xuICAgICAgY29uc3QgbGVmdCA9IHJlY3QubGVmdCAqIG1ldGEud2lkdGg7XG4gICAgICBjb25zdCB0b3AgPSByZWN0LnRvcCAqIG1ldGEuaGVpZ2h0O1xuICAgICAgY29uc3QgcmlnaHQgPSAocmVjdC5sZWZ0ICsgcmVjdC53aWR0aCkgKiBtZXRhLndpZHRoO1xuICAgICAgY29uc3QgYm90dG9tID0gKHJlY3QudG9wICsgcmVjdC5oZWlnaHQpICogbWV0YS5oZWlnaHQ7XG4gICAgICByZXR1cm4geCA+PSBsZWZ0ICYmIHggPD0gcmlnaHQgJiYgeSA+PSB0b3AgJiYgeSA8PSBib3R0b207XG4gICAgfSk7XG4gICAgdGFyZ2V0LnN0eWxlLmN1cnNvciA9IGhpdCA/IFwidGV4dFwiIDogXCJkZWZhdWx0XCI7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUG9pbnRlckxlYXZlID0gKGV2ZW50OiBQb2ludGVyRXZlbnQpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxEaXZFbGVtZW50O1xuICAgIHRhcmdldC5zdHlsZS5jdXJzb3IgPSBcImRlZmF1bHRcIjtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVQb2ludGVyRG93biA9IChldmVudDogUG9pbnRlckV2ZW50KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICBjb25zdCBwYWdlTnVtYmVyID0gTnVtYmVyKHRhcmdldC5wYXJlbnRFbGVtZW50Py5kYXRhc2V0LnBhZ2VOdW1iZXIpO1xuICAgIGlmICghcGFnZU51bWJlcikgcmV0dXJuO1xuICAgIGNvbnN0IHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgc3RhcnRYID0gZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICBjb25zdCBzdGFydFkgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgdGFyZ2V0LnF1ZXJ5U2VsZWN0b3JBbGwoXCIucGRmLWVtYmVkX19oaWdobGlnaHRcIikuZm9yRWFjaCgobm9kZSkgPT4gbm9kZS5yZW1vdmUoKSk7XG4gICAgaWYgKHBvcHVwUmVmLmN1cnJlbnQpIHtcbiAgICAgIHBvcHVwUmVmLmN1cnJlbnQucmVtb3ZlKCk7XG4gICAgICBwb3B1cFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgc2VsZWN0aW9uUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIGNvbnN0IG1ldGEgPSBwYWdlTWV0YVJlZi5jdXJyZW50W3BhZ2VOdW1iZXJdO1xuICAgIGNvbnN0IHJlY3RzID0gd29yZFJlY3RzUmVmLmN1cnJlbnRbcGFnZU51bWJlcl0gfHwgW107XG4gICAgY29uc3Qgc3RhcnRXb3JkSW5kZXggPVxuICAgICAgbWV0YSAmJiByZWN0cy5sZW5ndGggPiAwID8gZmluZFdvcmRJbmRleEF0UG9pbnQocmVjdHMsIG1ldGEsIHN0YXJ0WCwgc3RhcnRZKSA6IG51bGw7XG4gICAgc2VsZWN0aW9uU3RhdGVSZWYuY3VycmVudCA9IHsgcGFnZU51bWJlciwgc3RhcnRYLCBzdGFydFksIHN0YXJ0V29yZEluZGV4IH07XG4gICAgdGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUG9pbnRlclVwID0gKGV2ZW50OiBQb2ludGVyRXZlbnQpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxEaXZFbGVtZW50O1xuICAgIHRhcmdldC5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBzZWxlY3Rpb25TdGF0ZVJlZi5jdXJyZW50O1xuICAgIGlmICghc2VsZWN0aW9uKSByZXR1cm47XG4gICAgc2VsZWN0aW9uUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIHNlbGVjdGlvblN0YXRlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIGNvbnN0IHN0YXJ0UGFnZU51bWJlciA9IHNlbGVjdGlvbi5wYWdlTnVtYmVyO1xuICAgIGNvbnN0IG92ZXJsYXkgPSBnZXRPdmVybGF5RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpID8/IHRhcmdldDtcbiAgICBjb25zdCBlbmRQYWdlTnVtYmVyID0gTnVtYmVyKFxuICAgICAgb3ZlcmxheS5kYXRhc2V0LnBhZ2VOdW1iZXIgPz8gb3ZlcmxheS5wYXJlbnRFbGVtZW50Py5kYXRhc2V0LnBhZ2VOdW1iZXJcbiAgICApO1xuICAgIGlmICghZW5kUGFnZU51bWJlcikgcmV0dXJuO1xuICAgIGNvbnN0IHRhcmdldFJlY3QgPSBvdmVybGF5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgY29uc3QgbWV0YSA9IHBhZ2VNZXRhUmVmLmN1cnJlbnRbZW5kUGFnZU51bWJlcl07XG4gICAgY29uc3QgcmVjdHMgPSB3b3JkUmVjdHNSZWYuY3VycmVudFtlbmRQYWdlTnVtYmVyXSB8fCBbXTtcbiAgICBpZiAoIW1ldGEgfHwgcmVjdHMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICBjb25zdCBjdXJyZW50WCA9IGV2ZW50LmNsaWVudFggLSB0YXJnZXRSZWN0LmxlZnQ7XG4gICAgY29uc3QgY3VycmVudFkgPSBldmVudC5jbGllbnRZIC0gdGFyZ2V0UmVjdC50b3A7XG4gICAgY29uc3Qgc3RhcnRXb3JkSW5kZXggPSBzZWxlY3Rpb24uc3RhcnRXb3JkSW5kZXg7XG4gICAgaWYgKHN0YXJ0V29yZEluZGV4ID09PSBudWxsKSByZXR1cm47XG4gICAgY29uc3QgY3VycmVudFdvcmRJbmRleCA9XG4gICAgICBmaW5kV29yZEluZGV4QXRQb2ludChyZWN0cywgbWV0YSwgY3VycmVudFgsIGN1cnJlbnRZKSA/P1xuICAgICAgZmluZExhc3RXb3JkSW5kZXhCZWZvcmVQb2ludChyZWN0cywgbWV0YSwgY3VycmVudFgsIGN1cnJlbnRZKTtcbiAgICBpZiAoY3VycmVudFdvcmRJbmRleCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIHJlbmRlckhpZ2hsaWdodHNBY3Jvc3NQYWdlcyhcbiAgICAgIHN0YXJ0UGFnZU51bWJlcixcbiAgICAgIHN0YXJ0V29yZEluZGV4LFxuICAgICAgZW5kUGFnZU51bWJlcixcbiAgICAgIGN1cnJlbnRXb3JkSW5kZXgsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfTtcblxuICBjb25zdCByZW5kZXJIaWdobGlnaHRzQnlJbmRleCA9IChcbiAgICB0YXJnZXQ6IEhUTUxEaXZFbGVtZW50LFxuICAgIHJlY3RzOiBXb3JkUmVjdFtdLFxuICAgIG1ldGE6IFBhZ2VNZXRhLFxuICAgIHN0YXJ0SW5kZXg6IG51bWJlcixcbiAgICBlbmRJbmRleDogbnVtYmVyLFxuICAgIHNob3dQb3B1cEFmdGVyOiBib29sZWFuXG4gICkgPT4ge1xuICAgIGNvbnN0IG1pbkluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgIGNvbnN0IG1heEluZGV4ID0gTWF0aC5tYXgoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgIHRhcmdldC5xdWVyeVNlbGVjdG9yQWxsKFwiLnBkZi1lbWJlZF9faGlnaGxpZ2h0XCIpLmZvckVhY2goKG5vZGUpID0+IG5vZGUucmVtb3ZlKCkpO1xuICAgIGxldCBib3VuZHM6IHsgbGVmdDogbnVtYmVyOyB0b3A6IG51bWJlcjsgcmlnaHQ6IG51bWJlcjsgYm90dG9tOiBudW1iZXIgfSB8IG51bGwgPVxuICAgICAgbnVsbDtcbiAgICBjb25zdCBzZWxlY3RlZCA9IHJlY3RzLmZpbHRlcihcbiAgICAgIChyZWN0KSA9PiByZWN0LndvcmRJbmRleCA+PSBtaW5JbmRleCAmJiByZWN0LndvcmRJbmRleCA8PSBtYXhJbmRleFxuICAgICk7XG4gICAgY29uc3QgZ3JvdXBzID0gZ3JvdXBSZWN0c0J5TGluZShzZWxlY3RlZCk7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBncm91cHMpIHtcbiAgICAgIGNvbnN0IGxlZnQgPSBncm91cC5sZWZ0ICogbWV0YS53aWR0aDtcbiAgICAgIGNvbnN0IHRvcCA9IGdyb3VwLnRvcCAqIG1ldGEuaGVpZ2h0O1xuICAgICAgY29uc3QgcmlnaHQgPSAoZ3JvdXAubGVmdCArIGdyb3VwLndpZHRoKSAqIG1ldGEud2lkdGg7XG4gICAgICBjb25zdCBib3R0b20gPSAoZ3JvdXAudG9wICsgZ3JvdXAuaGVpZ2h0KSAqIG1ldGEuaGVpZ2h0O1xuICAgICAgaWYgKCFib3VuZHMpIHtcbiAgICAgICAgYm91bmRzID0geyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0gTWF0aC5taW4oYm91bmRzLmxlZnQsIGxlZnQpO1xuICAgICAgICBib3VuZHMudG9wID0gTWF0aC5taW4oYm91bmRzLnRvcCwgdG9wKTtcbiAgICAgICAgYm91bmRzLnJpZ2h0ID0gTWF0aC5tYXgoYm91bmRzLnJpZ2h0LCByaWdodCk7XG4gICAgICAgIGJvdW5kcy5ib3R0b20gPSBNYXRoLm1heChib3VuZHMuYm90dG9tLCBib3R0b20pO1xuICAgICAgfVxuICAgICAgY29uc3QgaGlnaGxpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGhpZ2hsaWdodC5jbGFzc05hbWUgPSBcInBkZi1lbWJlZF9faGlnaGxpZ2h0XCI7XG4gICAgICBoaWdobGlnaHQuc3R5bGUubGVmdCA9IGAke2xlZnR9cHhgO1xuICAgICAgaGlnaGxpZ2h0LnN0eWxlLnRvcCA9IGAke3RvcH1weGA7XG4gICAgICBoaWdobGlnaHQuc3R5bGUud2lkdGggPSBgJHtyaWdodCAtIGxlZnR9cHhgO1xuICAgICAgaGlnaGxpZ2h0LnN0eWxlLmhlaWdodCA9IGAke2JvdHRvbSAtIHRvcH1weGA7XG4gICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoaGlnaGxpZ2h0KTtcbiAgICB9XG4gICAgaWYgKGJvdW5kcyAmJiBzaG93UG9wdXBBZnRlcikge1xuICAgICAgY29uc3QgYW5jaG9yID0gZ2V0V29yZEFuY2hvcihyZWN0cywgbWV0YSwgZW5kSW5kZXgpO1xuICAgICAgc2hvd1BvcHVwKHRhcmdldCwgYm91bmRzLCBhbmNob3IgPz8gdW5kZWZpbmVkKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVuZGVySGlnaGxpZ2h0c0Fjcm9zc1BhZ2VzID0gKFxuICAgIHN0YXJ0UGFnZTogbnVtYmVyLFxuICAgIHN0YXJ0SW5kZXg6IG51bWJlcixcbiAgICBlbmRQYWdlOiBudW1iZXIsXG4gICAgZW5kSW5kZXg6IG51bWJlcixcbiAgICBzaG93UG9wdXBBZnRlcjogYm9vbGVhblxuICApID0+IHtcbiAgICBjbGVhckFsbEhpZ2hsaWdodHMoKTtcbiAgICBjb25zdCBwYWdlcyA9IE9iamVjdC5rZXlzKHdvcmRSZWN0c1JlZi5jdXJyZW50KVxuICAgICAgLm1hcCgoa2V5KSA9PiBOdW1iZXIoa2V5KSlcbiAgICAgIC5maWx0ZXIoKHBhZ2UpID0+IE51bWJlci5pc0Zpbml0ZShwYWdlKSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgaWYgKHBhZ2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IGZvcndhcmQgPSBzdGFydFBhZ2UgPD0gZW5kUGFnZTtcbiAgICBjb25zdCBmcm9tUGFnZSA9IGZvcndhcmQgPyBzdGFydFBhZ2UgOiBlbmRQYWdlO1xuICAgIGNvbnN0IHRvUGFnZSA9IGZvcndhcmQgPyBlbmRQYWdlIDogc3RhcnRQYWdlO1xuICAgIGZvciAoY29uc3QgcGFnZU51bWJlciBvZiBwYWdlcykge1xuICAgICAgaWYgKHBhZ2VOdW1iZXIgPCBmcm9tUGFnZSB8fCBwYWdlTnVtYmVyID4gdG9QYWdlKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHJlY3RzID0gd29yZFJlY3RzUmVmLmN1cnJlbnRbcGFnZU51bWJlcl0gfHwgW107XG4gICAgICBjb25zdCBtZXRhID0gcGFnZU1ldGFSZWYuY3VycmVudFtwYWdlTnVtYmVyXTtcbiAgICAgIGNvbnN0IG92ZXJsYXkgPSBnZXRPdmVybGF5Rm9yUGFnZShwYWdlTnVtYmVyKTtcbiAgICAgIGlmICghcmVjdHMubGVuZ3RoIHx8ICFtZXRhIHx8ICFvdmVybGF5KSBjb250aW51ZTtcbiAgICAgIGNvbnN0IFtyYW5nZVN0YXJ0LCByYW5nZUVuZF0gPSBnZXRQYWdlU2VsZWN0aW9uUmFuZ2UoXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwYWdlTnVtYmVyLFxuICAgICAgICBzdGFydFBhZ2UsXG4gICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgIGVuZFBhZ2UsXG4gICAgICAgIGVuZEluZGV4XG4gICAgICApO1xuICAgICAgcmVuZGVySGlnaGxpZ2h0c0J5SW5kZXgob3ZlcmxheSwgcmVjdHMsIG1ldGEsIHJhbmdlU3RhcnQsIHJhbmdlRW5kLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChzaG93UG9wdXBBZnRlcikge1xuICAgICAgY29uc3QgdGFyZ2V0UGFnZSA9IGVuZFBhZ2U7XG4gICAgICBjb25zdCByZWN0cyA9IHdvcmRSZWN0c1JlZi5jdXJyZW50W3RhcmdldFBhZ2VdIHx8IFtdO1xuICAgICAgY29uc3QgbWV0YSA9IHBhZ2VNZXRhUmVmLmN1cnJlbnRbdGFyZ2V0UGFnZV07XG4gICAgICBjb25zdCBvdmVybGF5ID0gZ2V0T3ZlcmxheUZvclBhZ2UodGFyZ2V0UGFnZSk7XG4gICAgICBpZiAocmVjdHMubGVuZ3RoICYmIG1ldGEgJiYgb3ZlcmxheSkge1xuICAgICAgICBjb25zdCBbcmFuZ2VTdGFydCwgcmFuZ2VFbmRdID0gZ2V0UGFnZVNlbGVjdGlvblJhbmdlKFxuICAgICAgICAgIHJlY3RzLFxuICAgICAgICAgIHRhcmdldFBhZ2UsXG4gICAgICAgICAgc3RhcnRQYWdlLFxuICAgICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgICAgZW5kUGFnZSxcbiAgICAgICAgICBlbmRJbmRleFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBhbmNob3JJbmRleCA9IHJhbmdlRW5kO1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHJlY3RzLmZpbHRlcihcbiAgICAgICAgICAocmVjdCkgPT4gcmVjdC53b3JkSW5kZXggPj0gcmFuZ2VTdGFydCAmJiByZWN0LndvcmRJbmRleCA8PSByYW5nZUVuZFxuICAgICAgICApO1xuICAgICAgICBsZXQgYm91bmRzOiB7IGxlZnQ6IG51bWJlcjsgdG9wOiBudW1iZXI7IHJpZ2h0OiBudW1iZXI7IGJvdHRvbTogbnVtYmVyIH0gfCBudWxsID1cbiAgICAgICAgICBudWxsO1xuICAgICAgICBjb25zdCBncm91cHMgPSBncm91cFJlY3RzQnlMaW5lKHNlbGVjdGVkKTtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBncm91cHMpIHtcbiAgICAgICAgICBjb25zdCBsZWZ0ID0gZ3JvdXAubGVmdCAqIG1ldGEud2lkdGg7XG4gICAgICAgICAgY29uc3QgdG9wID0gZ3JvdXAudG9wICogbWV0YS5oZWlnaHQ7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSAoZ3JvdXAubGVmdCArIGdyb3VwLndpZHRoKSAqIG1ldGEud2lkdGg7XG4gICAgICAgICAgY29uc3QgYm90dG9tID0gKGdyb3VwLnRvcCArIGdyb3VwLmhlaWdodCkgKiBtZXRhLmhlaWdodDtcbiAgICAgICAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICAgICAgYm91bmRzID0geyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20gfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm91bmRzLmxlZnQgPSBNYXRoLm1pbihib3VuZHMubGVmdCwgbGVmdCk7XG4gICAgICAgICAgICBib3VuZHMudG9wID0gTWF0aC5taW4oYm91bmRzLnRvcCwgdG9wKTtcbiAgICAgICAgICAgIGJvdW5kcy5yaWdodCA9IE1hdGgubWF4KGJvdW5kcy5yaWdodCwgcmlnaHQpO1xuICAgICAgICAgICAgYm91bmRzLmJvdHRvbSA9IE1hdGgubWF4KGJvdW5kcy5ib3R0b20sIGJvdHRvbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChib3VuZHMpIHtcbiAgICAgICAgICBjb25zdCBhbmNob3IgPSBnZXRXb3JkQW5jaG9yKHJlY3RzLCBtZXRhLCBhbmNob3JJbmRleCk7XG4gICAgICAgICAgc2hvd1BvcHVwKG92ZXJsYXksIGJvdW5kcywgYW5jaG9yID8/IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc2hvd1BvcHVwID0gKFxuICAgIHRhcmdldDogSFRNTERpdkVsZW1lbnQsXG4gICAgYm91bmRzOiB7IGxlZnQ6IG51bWJlcjsgdG9wOiBudW1iZXI7IHJpZ2h0OiBudW1iZXI7IGJvdHRvbTogbnVtYmVyIH0sXG4gICAgYW5jaG9yPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9XG4gICkgPT4ge1xuICAgIGlmIChwb3B1cFJlZi5jdXJyZW50KSB7XG4gICAgICBwb3B1cFJlZi5jdXJyZW50LnJlbW92ZSgpO1xuICAgICAgcG9wdXBSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBvcHVwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBwb3B1cC5jbGFzc05hbWUgPSBcInBkZi1lbWJlZF9fcG9wdXBcIjtcbiAgICBwb3B1cC5pbm5lckhUTUwgPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwicGRmLWVtYmVkX19wb3B1cC1wYWxldHRlXCIgYXJpYS1sYWJlbD1cIkhpZ2hsaWdodCBjb2xvcnNcIj5cbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJwZGYtZW1iZWRfX3BhbGV0dGUtY29sb3IgaXMtc2VsZWN0ZWRcIiBzdHlsZT1cIi0tc3dhdGNoOiNmZmQ4NGRcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cInBkZi1lbWJlZF9fcGFsZXR0ZS1jaGVja1wiPuKckzwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicGRmLWVtYmVkX19wYWxldHRlLWNvbG9yXCIgc3R5bGU9XCItLXN3YXRjaDojZmZiMzQ3XCI+PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicGRmLWVtYmVkX19wYWxldHRlLWNvbG9yXCIgc3R5bGU9XCItLXN3YXRjaDojZmY3YjdiXCI+PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicGRmLWVtYmVkX19wYWxldHRlLWNvbG9yXCIgc3R5bGU9XCItLXN3YXRjaDojZmY4YmQxXCI+PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicGRmLWVtYmVkX19wYWxldHRlLWNvbG9yXCIgc3R5bGU9XCItLXN3YXRjaDojYjI4Y2ZmXCI+PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicGRmLWVtYmVkX19wYWxldHRlLWNvbG9yXCIgc3R5bGU9XCItLXN3YXRjaDojN2FhOWZmXCI+PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicGRmLWVtYmVkX19wYWxldHRlLWNvbG9yXCIgc3R5bGU9XCItLXN3YXRjaDojNjlkMmZmXCI+PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicGRmLWVtYmVkX19wYWxldHRlLWNvbG9yXCIgc3R5bGU9XCItLXN3YXRjaDojNjVlMGExXCI+PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicGRmLWVtYmVkX19wYWxldHRlLWNvbG9yXCIgc3R5bGU9XCItLXN3YXRjaDojYzdlYTZiXCI+PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicGRmLWVtYmVkX19wYWxldHRlLWNvbG9yXCIgc3R5bGU9XCItLXN3YXRjaDojZmZlNGEzXCI+PC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicGRmLWVtYmVkX19wb3B1cC1idG5cIj5cbiAgICAgICAgPHN2ZyBjbGFzcz1cInBkZi1lbWJlZF9fcG9wdXAtaWNvblwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICAgICAgICA8ZyB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTIgMTIpIHNjYWxlKDEuMSkgdHJhbnNsYXRlKC0xMiAtMTIpXCI+XG4gICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICBkPVwiTTQgMTYuNVYyMGgzLjVMMTguOCA4LjdsLTMuNS0zLjVMNCAxNi41elwiXG4gICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAgc3Ryb2tlLXdpZHRoPVwiMlwiXG4gICAgICAgICAgICAgIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICBkPVwiTTEzLjggNS4ybDMuNSAzLjVcIlxuICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgIHN0cm9rZS13aWR0aD1cIjJcIlxuICAgICAgICAgICAgICBzdHJva2UtbGluZWNhcD1cInJvdW5kXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9nPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAgSGlnaGxpZ2h0XG4gICAgICAgIDxzcGFuIGNsYXNzPVwicGRmLWVtYmVkX19wb3B1cC1zaG9ydGN1dFwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwicGRmLWVtYmVkX19wb3B1cC1rZXlcIj7ijJg8L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJwZGYtZW1iZWRfX3BvcHVwLWtleVwiPkg8L3NwYW4+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJwZGYtZW1iZWRfX3BvcHVwLWJ0blwiPlxuICAgICAgICA8c3ZnIGNsYXNzPVwicGRmLWVtYmVkX19wb3B1cC1pY29uXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgICAgICAgIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxMiAxMikgc2NhbGUoMS4xKSB0cmFuc2xhdGUoLTEyIC0xMilcIj5cbiAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgIGQ9XCJNOCA0djdhNCA0IDAgMCAwIDggMFY0XCJcbiAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICBzdHJva2Utd2lkdGg9XCIyXCJcbiAgICAgICAgICAgICAgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgZD1cIk01IDIwaDE0XCJcbiAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICBzdHJva2Utd2lkdGg9XCIyXCJcbiAgICAgICAgICAgICAgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgPC9zdmc+XG4gICAgICAgIFVuZGVybGluZVxuICAgICAgICA8c3BhbiBjbGFzcz1cInBkZi1lbWJlZF9fcG9wdXAtc2hvcnRjdXRcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cInBkZi1lbWJlZF9fcG9wdXAta2V5XCI+4oyYPC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwicGRmLWVtYmVkX19wb3B1cC1rZXlcIj5VPC9zcGFuPlxuICAgICAgICA8L3NwYW4+XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicGRmLWVtYmVkX19wb3B1cC1idG5cIj5cbiAgICAgICAgPHN2ZyBjbGFzcz1cInBkZi1lbWJlZF9fcG9wdXAtaWNvblwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICAgICAgICA8ZyB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTIgMTIpIHNjYWxlKDEuMSkgdHJhbnNsYXRlKC0xMiAtMTIpXCI+XG4gICAgICAgICAgICA8cmVjdFxuICAgICAgICAgICAgICB4PVwiOFwiXG4gICAgICAgICAgICAgIHk9XCI4XCJcbiAgICAgICAgICAgICAgd2lkdGg9XCIxMFwiXG4gICAgICAgICAgICAgIGhlaWdodD1cIjEwXCJcbiAgICAgICAgICAgICAgcng9XCIyXCJcbiAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICBzdHJva2Utd2lkdGg9XCIyXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICBkPVwiTTYgMTZINWEyIDIgMCAwIDEtMi0yVjdhMiAyIDAgMCAxIDItMmg3YTIgMiAwIDAgMSAyIDJ2MVwiXG4gICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAgc3Ryb2tlLXdpZHRoPVwiMlwiXG4gICAgICAgICAgICAgIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2c+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgICBDb3B5XG4gICAgICAgIDxzcGFuIGNsYXNzPVwicGRmLWVtYmVkX19wb3B1cC1zaG9ydGN1dFwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwicGRmLWVtYmVkX19wb3B1cC1rZXlcIj7ijJg8L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJwZGYtZW1iZWRfX3BvcHVwLWtleVwiPkM8L3NwYW4+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJwZGYtZW1iZWRfX3BvcHVwLWJ0blwiPlxuICAgICAgICA8c3ZnIGNsYXNzPVwicGRmLWVtYmVkX19wb3B1cC1pY29uXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgICAgICAgIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxMiAxMikgc2NhbGUoMS4xKSB0cmFuc2xhdGUoLTEyIC0xMilcIj5cbiAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgIGQ9XCJNNCA4YTMgMyAwIDAgMSAzLTNoMTBhMyAzIDAgMCAxIDMgM3Y2YTMgMyAwIDAgMS0zIDNIOWwtNCAzdi0zSDdhMyAzIDAgMCAxLTMtM1Y4elwiXG4gICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAgc3Ryb2tlLXdpZHRoPVwiMlwiXG4gICAgICAgICAgICAgIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICBkPVwiTTEyIDl2Nk05IDEyaDZcIlxuICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgIHN0cm9rZS13aWR0aD1cIjJcIlxuICAgICAgICAgICAgICBzdHJva2UtbGluZWNhcD1cInJvdW5kXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9nPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAgQWRkIHRvIGNoYXRcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJwZGYtZW1iZWRfX3BvcHVwLXNob3J0Y3V0XCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJwZGYtZW1iZWRfX3BvcHVwLWtleVwiPuKMmDwvc3Bhbj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cInBkZi1lbWJlZF9fcG9wdXAta2V5XCI+QTwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9idXR0b24+XG4gICAgYDtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQocG9wdXApO1xuICAgIGNvbnN0IHsgd2lkdGg6IHBvcHVwV2lkdGgsIGhlaWdodDogcG9wdXBIZWlnaHQgfSA9IHBvcHVwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IG1heExlZnQgPSBNYXRoLm1heCg2LCB0YXJnZXQuY2xpZW50V2lkdGggLSBwb3B1cFdpZHRoIC0gNik7XG4gICAgY29uc3QgbWF4VG9wID0gTWF0aC5tYXgoNiwgdGFyZ2V0LmNsaWVudEhlaWdodCAtIHBvcHVwSGVpZ2h0IC0gNik7XG4gICAgY29uc3QgYW5jaG9yWCA9IGFuY2hvciA/IGFuY2hvci54IDogYm91bmRzLnJpZ2h0O1xuICAgIGNvbnN0IGFuY2hvclkgPSBhbmNob3IgPyBhbmNob3IueSA6IGJvdW5kcy5ib3R0b207XG4gICAgY29uc3QgbGVmdCA9IE1hdGgubWF4KDYsIE1hdGgubWluKGFuY2hvclggKyA4LCBtYXhMZWZ0KSk7XG4gICAgY29uc3QgdG9wID0gTWF0aC5tYXgoNiwgTWF0aC5taW4oYW5jaG9yWSArIDgsIG1heFRvcCkpO1xuICAgIHBvcHVwLnN0eWxlLmxlZnQgPSBgJHtsZWZ0fXB4YDtcbiAgICBwb3B1cC5zdHlsZS50b3AgPSBgJHt0b3B9cHhgO1xuICAgIHBvcHVwUmVmLmN1cnJlbnQgPSBwb3B1cDtcbiAgfTtcblxuICBjb25zdCBnZXRXb3JkQW5jaG9yID0gKHJlY3RzOiBXb3JkUmVjdFtdLCBtZXRhOiBQYWdlTWV0YSwgd29yZEluZGV4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCByZWN0ID0gcmVjdHMuZmluZCgoaXRlbSkgPT4gaXRlbS53b3JkSW5kZXggPT09IHdvcmRJbmRleCk7XG4gICAgaWYgKCFyZWN0KSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgeDogKHJlY3QubGVmdCArIHJlY3Qud2lkdGgpICogbWV0YS53aWR0aCxcbiAgICAgIHk6IChyZWN0LnRvcCArIHJlY3QuaGVpZ2h0KSAqIG1ldGEuaGVpZ2h0LFxuICAgIH07XG4gIH07XG5cbiAgY29uc3QgZ2V0UGFnZVNlbGVjdGlvblJhbmdlID0gKFxuICAgIHJlY3RzOiBXb3JkUmVjdFtdLFxuICAgIHBhZ2VOdW1iZXI6IG51bWJlcixcbiAgICBzdGFydFBhZ2U6IG51bWJlcixcbiAgICBzdGFydEluZGV4OiBudW1iZXIsXG4gICAgZW5kUGFnZTogbnVtYmVyLFxuICAgIGVuZEluZGV4OiBudW1iZXJcbiAgKSA9PiB7XG4gICAgY29uc3QgZmlyc3RJbmRleCA9IHJlY3RzWzBdLndvcmRJbmRleDtcbiAgICBjb25zdCBsYXN0SW5kZXggPSByZWN0c1tyZWN0cy5sZW5ndGggLSAxXS53b3JkSW5kZXg7XG4gICAgaWYgKHN0YXJ0UGFnZSA9PT0gZW5kUGFnZSkge1xuICAgICAgcmV0dXJuIFtNYXRoLm1pbihzdGFydEluZGV4LCBlbmRJbmRleCksIE1hdGgubWF4KHN0YXJ0SW5kZXgsIGVuZEluZGV4KV07XG4gICAgfVxuICAgIGlmIChzdGFydFBhZ2UgPCBlbmRQYWdlKSB7XG4gICAgICBpZiAocGFnZU51bWJlciA9PT0gc3RhcnRQYWdlKSByZXR1cm4gW3N0YXJ0SW5kZXgsIGxhc3RJbmRleF07XG4gICAgICBpZiAocGFnZU51bWJlciA9PT0gZW5kUGFnZSkgcmV0dXJuIFtmaXJzdEluZGV4LCBlbmRJbmRleF07XG4gICAgICByZXR1cm4gW2ZpcnN0SW5kZXgsIGxhc3RJbmRleF07XG4gICAgfVxuICAgIGlmIChwYWdlTnVtYmVyID09PSBzdGFydFBhZ2UpIHJldHVybiBbZmlyc3RJbmRleCwgc3RhcnRJbmRleF07XG4gICAgaWYgKHBhZ2VOdW1iZXIgPT09IGVuZFBhZ2UpIHJldHVybiBbZW5kSW5kZXgsIGxhc3RJbmRleF07XG4gICAgcmV0dXJuIFtmaXJzdEluZGV4LCBsYXN0SW5kZXhdO1xuICB9O1xuXG4gIGNvbnN0IGNsZWFyQWxsSGlnaGxpZ2h0cyA9ICgpID0+IHtcbiAgICBpZiAoIWNvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgY29udGFpbmVyUmVmLmN1cnJlbnRcbiAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKFwiLnBkZi1lbWJlZF9faGlnaGxpZ2h0XCIpXG4gICAgICAuZm9yRWFjaCgobm9kZSkgPT4gbm9kZS5yZW1vdmUoKSk7XG4gIH07XG5cbiAgY29uc3QgZ2V0T3ZlcmxheUZvclBhZ2UgPSAocGFnZU51bWJlcjogbnVtYmVyKSA9PiB7XG4gICAgaWYgKCFjb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGNvbnRhaW5lclJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICBgLnBkZi1lbWJlZF9fb3ZlcmxheVtkYXRhLXBhZ2UtbnVtYmVyPVwiJHtwYWdlTnVtYmVyfVwiXWBcbiAgICApIGFzIEhUTUxEaXZFbGVtZW50IHwgbnVsbDtcbiAgfTtcblxuICBjb25zdCBnZXRPdmVybGF5RnJvbVBvaW50ID0gKHg6IG51bWJlciwgeTogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgaWYgKCFlbGVtZW50KSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gZWxlbWVudC5jbG9zZXN0KFwiLnBkZi1lbWJlZF9fb3ZlcmxheVwiKSBhcyBIVE1MRGl2RWxlbWVudCB8IG51bGw7XG4gIH07XG5cbiAgY29uc3QgZ3JvdXBSZWN0c0J5TGluZSA9IChyZWN0czogV29yZFJlY3RbXSkgPT4ge1xuICAgIGlmIChyZWN0cy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgICBjb25zdCBzb3J0ZWQgPSBbLi4ucmVjdHNdLnNvcnQoXG4gICAgICAoYSwgYikgPT5cbiAgICAgICAgKGEubGluZUlkID8/IDApIC0gKGIubGluZUlkID8/IDApIHx8XG4gICAgICAgIGEudG9wIC0gYi50b3AgfHxcbiAgICAgICAgYS5sZWZ0IC0gYi5sZWZ0XG4gICAgKTtcbiAgICBjb25zdCBncm91cHM6IFdvcmRSZWN0W10gPSBbXTtcbiAgICBsZXQgY3VycmVudCA9IHsgLi4uc29ydGVkWzBdIH07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzb3J0ZWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBzb3J0ZWRbaV07XG4gICAgICBjb25zdCBzYW1lTGluZSA9IHJlY3QubGluZUlkICE9PSBudWxsICYmIHJlY3QubGluZUlkID09PSBjdXJyZW50LmxpbmVJZDtcbiAgICAgIGlmIChzYW1lTGluZSkge1xuICAgICAgICBjb25zdCBuZXdMZWZ0ID0gTWF0aC5taW4oY3VycmVudC5sZWZ0LCByZWN0LmxlZnQpO1xuICAgICAgICBjb25zdCBuZXdSaWdodCA9IE1hdGgubWF4KFxuICAgICAgICAgIGN1cnJlbnQubGVmdCArIGN1cnJlbnQud2lkdGgsXG4gICAgICAgICAgcmVjdC5sZWZ0ICsgcmVjdC53aWR0aFxuICAgICAgICApO1xuICAgICAgICBjdXJyZW50LmxlZnQgPSBuZXdMZWZ0O1xuICAgICAgICBjdXJyZW50LndpZHRoID0gbmV3UmlnaHQgLSBuZXdMZWZ0O1xuICAgICAgICBjdXJyZW50LmhlaWdodCA9IE1hdGgubWF4KGN1cnJlbnQuaGVpZ2h0LCByZWN0LmhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncm91cHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgY3VycmVudCA9IHsgLi4ucmVjdCB9O1xuICAgICAgfVxuICAgIH1cbiAgICBncm91cHMucHVzaChjdXJyZW50KTtcbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9O1xuXG4gIGNvbnN0IGZpbmRXb3JkSW5kZXhBdFBvaW50ID0gKFxuICAgIHJlY3RzOiBXb3JkUmVjdFtdLFxuICAgIG1ldGE6IFBhZ2VNZXRhLFxuICAgIHg6IG51bWJlcixcbiAgICB5OiBudW1iZXJcbiAgKSA9PiB7XG4gICAgZm9yIChjb25zdCByZWN0SXRlbSBvZiByZWN0cykge1xuICAgICAgY29uc3QgbGVmdCA9IHJlY3RJdGVtLmxlZnQgKiBtZXRhLndpZHRoO1xuICAgICAgY29uc3QgdG9wID0gcmVjdEl0ZW0udG9wICogbWV0YS5oZWlnaHQ7XG4gICAgICBjb25zdCByaWdodCA9IChyZWN0SXRlbS5sZWZ0ICsgcmVjdEl0ZW0ud2lkdGgpICogbWV0YS53aWR0aDtcbiAgICAgIGNvbnN0IGJvdHRvbSA9IChyZWN0SXRlbS50b3AgKyByZWN0SXRlbS5oZWlnaHQpICogbWV0YS5oZWlnaHQ7XG4gICAgICBpZiAoeCA+PSBsZWZ0ICYmIHggPD0gcmlnaHQgJiYgeSA+PSB0b3AgJiYgeSA8PSBib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIHJlY3RJdGVtLndvcmRJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgY29uc3QgZmluZExhc3RXb3JkSW5kZXhCZWZvcmVQb2ludCA9IChcbiAgICByZWN0czogV29yZFJlY3RbXSxcbiAgICBtZXRhOiBQYWdlTWV0YSxcbiAgICB4OiBudW1iZXIsXG4gICAgeTogbnVtYmVyXG4gICkgPT4ge1xuICAgIGxldCBiZXN0SW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgIGZvciAoY29uc3QgcmVjdEl0ZW0gb2YgcmVjdHMpIHtcbiAgICAgIGNvbnN0IGxlZnQgPSByZWN0SXRlbS5sZWZ0ICogbWV0YS53aWR0aDtcbiAgICAgIGNvbnN0IHRvcCA9IHJlY3RJdGVtLnRvcCAqIG1ldGEuaGVpZ2h0O1xuICAgICAgY29uc3QgcmlnaHQgPSAocmVjdEl0ZW0ubGVmdCArIHJlY3RJdGVtLndpZHRoKSAqIG1ldGEud2lkdGg7XG4gICAgICBjb25zdCBib3R0b20gPSAocmVjdEl0ZW0udG9wICsgcmVjdEl0ZW0uaGVpZ2h0KSAqIG1ldGEuaGVpZ2h0O1xuICAgICAgY29uc3QgY2VudGVyWCA9IChsZWZ0ICsgcmlnaHQpIC8gMjtcbiAgICAgIGNvbnN0IGNlbnRlclkgPSAodG9wICsgYm90dG9tKSAvIDI7XG4gICAgICBpZiAoY2VudGVyWSA8PSB5ICYmIGNlbnRlclggPD0geCkge1xuICAgICAgICBpZiAoYmVzdEluZGV4ID09PSBudWxsIHx8IHJlY3RJdGVtLndvcmRJbmRleCA+IGJlc3RJbmRleCkge1xuICAgICAgICAgIGJlc3RJbmRleCA9IHJlY3RJdGVtLndvcmRJbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmVzdEluZGV4O1xuICB9O1xuXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInBkZi1lbWJlZFwiPlxuICAgICAge3N0YXRlID09PSBcImxvYWRpbmdcIiA/IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJlbXB0eS1zdGF0ZVwiPlBERuOCkuiqreOBv+i+vOOBv+S4rS4uLjwvZGl2PlxuICAgICAgKSA6IG51bGx9XG4gICAgICB7c3RhdGUgPT09IFwiZXJyb3JcIiA/IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJlbXB0eS1zdGF0ZVwiPlxuICAgICAgICAgIFBERuOBruihqOekuuOBq+WkseaVl+OBl+OBvuOBl+OBn1xuICAgICAgICAgIHtlcnJvck1lc3NhZ2UgPyA8c3BhbiBjbGFzc05hbWU9XCJwZGYtZW1iZWRfX2Vycm9yXCI+e2Vycm9yTWVzc2FnZX08L3NwYW4+IDogbnVsbH1cbiAgICAgICAgPC9kaXY+XG4gICAgICApIDogbnVsbH1cbiAgICAgIDxkaXYgcmVmPXtjb250YWluZXJSZWZ9IGNsYXNzTmFtZT1cInBkZi1lbWJlZF9fcGFnZXNcIiAvPlxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiUGRmVmlld2VyIiwidXJsIiwiZG9jdW1lbnRJZCIsImFjY2Vzc1Rva2VuIiwiY29udGFpbmVyUmVmIiwic3RhdGUiLCJzZXRTdGF0ZSIsImVycm9yTWVzc2FnZSIsInNldEVycm9yTWVzc2FnZSIsInBhZ2VNZXRhIiwic2V0UGFnZU1ldGEiLCJwYWdlTWV0YVJlZiIsImRvY3VtZW50UmVzdWx0Iiwic2V0RG9jdW1lbnRSZXN1bHQiLCJ3b3JkUmVjdHNSZWYiLCJzZWxlY3Rpb25SZWYiLCJwb3B1cFJlZiIsInNlbGVjdGlvblN0YXRlUmVmIiwiY2FuY2VsbGVkIiwicmVuZGVyIiwiY29udGFpbmVyIiwiY3VycmVudCIsImlubmVySFRNTCIsInBkZmpzIiwiR2xvYmFsV29ya2VyT3B0aW9ucyIsIndvcmtlclNyYyIsImxvYWRpbmdUYXNrIiwiZ2V0RG9jdW1lbnQiLCJwZGYiLCJwcm9taXNlIiwiY29udGFpbmVyV2lkdGgiLCJjbGllbnRXaWR0aCIsIm5leHRNZXRhIiwicGFnZU51bSIsIm51bVBhZ2VzIiwicGFnZSIsImdldFBhZ2UiLCJ2aWV3cG9ydCIsImdldFZpZXdwb3J0Iiwic2NhbGUiLCJwYWdlV2lkdGgiLCJNYXRoIiwibWluIiwid2lkdGgiLCJzY2FsZWQiLCJwYWdlV3JhcHBlciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImRhdGFzZXQiLCJwYWdlTnVtYmVyIiwiU3RyaW5nIiwic3R5bGUiLCJmbG9vciIsIm1hcmdpbiIsImNhbnZhcyIsImhlaWdodCIsIm92ZXJsYXkiLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlUG9pbnRlck1vdmUiLCJoYW5kbGVQb2ludGVyTGVhdmUiLCJoYW5kbGVQb2ludGVyRG93biIsImhhbmRsZVBvaW50ZXJVcCIsInJlbW92ZSIsImFwcGVuZENoaWxkIiwiY29udGV4dCIsImdldENvbnRleHQiLCJjYW52YXNDb250ZXh0IiwiZXhpc3RpbmciLCJ3aWR0aEluY2giLCJoZWlnaHRJbmNoIiwiZXJyb3IiLCJtZXNzYWdlIiwiRXJyb3IiLCJsb2FkUmVzdWx0IiwicHJvY2VzcyIsImJhc2VVcmwiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfQkFTRV9VUkwiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJvayIsInJlc3VsdCIsImpzb24iLCJwYWdlcyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInByZXYiLCJtZXJnZWQiLCJOdW1iZXIiLCJwYWdlX251bWJlciIsImlzRmluaXRlIiwibmV4dFJlY3RzIiwicG9seWdvblRvUmVjdCIsInBvbHlnb24iLCJ4cyIsInlzIiwiaSIsInB1c2giLCJsZWZ0IiwicmlnaHQiLCJtYXgiLCJ0b3AiLCJib3R0b20iLCJ3b3JkcyIsImxpbmVzIiwid29yZFRvTGluZSIsIk1hcCIsImZvckVhY2giLCJsaW5lIiwiaW5kZXgiLCJpbmRleGVzIiwid29yZF9pbmRleGVzIiwid29yZEluZGV4ZXMiLCJ3b3JkSW5kZXgiLCJzZXQiLCJ3b3JkIiwicmVjdCIsIndvcmRfaW5kZXgiLCJtYXRjaGVkIiwiaW5jbHVkZXMiLCJsaW5lUmVjdCIsIm5vcm1hbGl6ZWQiLCJsaW5lSWQiLCJnZXQiLCJrZXkiLCJPYmplY3QiLCJrZXlzIiwic29ydCIsImEiLCJiIiwiZXZlbnQiLCJ0YXJnZXQiLCJjdXJyZW50VGFyZ2V0IiwicGFyZW50RWxlbWVudCIsImdldE92ZXJsYXlGcm9tUG9pbnQiLCJjbGllbnRYIiwiY2xpZW50WSIsImFjdGl2ZVBhZ2VOdW1iZXIiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjdXJyZW50WCIsImN1cnJlbnRZIiwibWV0YSIsInJlY3RzIiwic3RhcnRXb3JkSW5kZXgiLCJzdGFydFBhZ2VOdW1iZXIiLCJmaW5kV29yZEluZGV4QXRQb2ludCIsImN1cnJlbnRXb3JkSW5kZXgiLCJmaW5kTGFzdFdvcmRJbmRleEJlZm9yZVBvaW50IiwicmVuZGVySGlnaGxpZ2h0c0Fjcm9zc1BhZ2VzIiwiY3Vyc29yIiwieCIsInkiLCJoaXQiLCJzb21lIiwic3RhcnRYIiwic3RhcnRZIiwicXVlcnlTZWxlY3RvckFsbCIsIm5vZGUiLCJzZXRQb2ludGVyQ2FwdHVyZSIsInBvaW50ZXJJZCIsInJlbGVhc2VQb2ludGVyQ2FwdHVyZSIsInNlbGVjdGlvbiIsImVuZFBhZ2VOdW1iZXIiLCJ0YXJnZXRSZWN0IiwicmVuZGVySGlnaGxpZ2h0c0J5SW5kZXgiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJzaG93UG9wdXBBZnRlciIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJib3VuZHMiLCJzZWxlY3RlZCIsImZpbHRlciIsImdyb3VwcyIsImdyb3VwUmVjdHNCeUxpbmUiLCJncm91cCIsImhpZ2hsaWdodCIsImFuY2hvciIsImdldFdvcmRBbmNob3IiLCJzaG93UG9wdXAiLCJ1bmRlZmluZWQiLCJzdGFydFBhZ2UiLCJlbmRQYWdlIiwiY2xlYXJBbGxIaWdobGlnaHRzIiwibWFwIiwiZm9yd2FyZCIsImZyb21QYWdlIiwidG9QYWdlIiwiZ2V0T3ZlcmxheUZvclBhZ2UiLCJyYW5nZVN0YXJ0IiwicmFuZ2VFbmQiLCJnZXRQYWdlU2VsZWN0aW9uUmFuZ2UiLCJ0YXJnZXRQYWdlIiwiYW5jaG9ySW5kZXgiLCJwb3B1cCIsInBvcHVwV2lkdGgiLCJwb3B1cEhlaWdodCIsIm1heExlZnQiLCJtYXhUb3AiLCJjbGllbnRIZWlnaHQiLCJhbmNob3JYIiwiYW5jaG9yWSIsImZpbmQiLCJpdGVtIiwiZmlyc3RJbmRleCIsImxhc3RJbmRleCIsInF1ZXJ5U2VsZWN0b3IiLCJlbGVtZW50IiwiZWxlbWVudEZyb21Qb2ludCIsImNsb3Nlc3QiLCJzb3J0ZWQiLCJzYW1lTGluZSIsIm5ld0xlZnQiLCJuZXdSaWdodCIsInJlY3RJdGVtIiwiYmVzdEluZGV4IiwiY2VudGVyWCIsImNlbnRlclkiLCJkaXYiLCJzcGFuIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/pdf-viewer/pdf-viewer.tsx\n"));

/***/ })

});